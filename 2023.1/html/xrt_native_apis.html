<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
<!-- End Google Tag Manager -->
  <title>XRT Native APIs &mdash; XRT Master documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="XRT Native Library C++ API" href="xrt_native.main.html" />
    <link rel="prev" title="Xilinx OpenCL extension" href="opencl_extension.html" /> 
</head>

<body class="wy-body-for-nav">

<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
<!-- End Google Tag Manager --> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="index.html" class="icon icon-home"> XRT
            <img src="_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                Master
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">XRT and Vitis™ Platform Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building the XRT Software Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">XRT Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Use Model and Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="execution-model.html">Execution Model Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_kernel_executions.html">XRT Controlled Kernel Execution Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocess.html">Multi-Process Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2p.html">PCIe Peer-to-Peer (P2P)</a></li>
<li class="toctree-l1"><a class="reference internal" href="m2m.html">Memory-to-Memory (M2M)</a></li>
<li class="toctree-l1"><a class="reference internal" href="hm.html">Host Memory Access</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_ini.html">Configuration File xrt.ini</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Video Acceleration Using XMA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xma_user_guide.html">XMA Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_apps_dev.html">Application Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_plugin_dev.html">Plugin Development Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="xmakernels.main.html">XMA Upper Edge API Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma.main.html">XMA Lower Edge API Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_19.2.html">Migration from Legacy XMA</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User API Library</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="opencl_extension.html">Xilinx OpenCL extension</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">XRT Native APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#device-and-xclbin">Device and XCLBIN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#buffers">Buffers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#buffer-allocation-and-deallocation">1. Buffer allocation and deallocation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-special-buffers">Creating special Buffers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-buffers-from-the-user-pointer">Creating Buffers from the user pointer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#data-transfer-using-buffers">2. Data transfer using Buffers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api">I. Data transfer between host and device by Buffer read/write API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api">II. Data transfer between host and device by Buffer map API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iii-data-transfer-between-the-buffers-by-copy-api">III. Data transfer between the buffers by copy API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-other-buffer-apis">3. Miscellaneous other Buffer APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dma-buf-api">DMA-BUF API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sub-buffer-support">Sub-buffer support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-information">Buffer information</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#kernel-and-run">Kernel and Run</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#obtaining-kernel-object-from-xclbin">Obtaining kernel object from XCLBIN</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-bank-group-index-of-the-kernel-argument">Getting bank group index of the kernel argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executing-the-kernel">Executing the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-kernel-apis">Other kernel APIs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#user-managed-kernel">User Managed Kernel</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-xrt-ip-object-from-xclbin">Creating <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object from XCLBIN</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocating-buffers-for-the-ip-inputs-outputs">Allocating buffers for the IP inputs/outputs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-write-cu-mapped-registers">Reading and write CU mapped registers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#graph">Graph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph-opening-and-closing">Graph Opening and Closing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reset-functions">Reset Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-execution">Graph execution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#graph-execution-for-a-fixed-number-of-iterations">Graph execution for a fixed number of iterations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#infinite-graph-execution">Infinite Graph Execution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#measuring-aie-cycle-consumed-by-the-graph">Measuring AIE cycle consumed by the Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtp-runtime-parameter-control">RTP (Runtime Parameter) control</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dma-operation-to-and-from-global-memory-io">DMA operation to and from Global Memory IO</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#xrt-error-api">XRT Error API</a></li>
<li class="toctree-l2"><a class="reference internal" href="#asynchornous-programming-with-xrt-experimental">Asynchornous Programming with XRT (experimental)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#executing-synchronous-task-asynchronously">Executing synchronous task asynchronously</a></li>
<li class="toctree-l3"><a class="reference internal" href="#executing-multiple-tasks-through-queue">Executing multiple tasks through queue</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-events-to-synchronize-among-the-queues">Using events to synchronize among the queues</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html">XRT Native Library C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html#id1">XRT Native Library C API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">XRT Developer's Space</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms_partitions.html">Alveo™ Platform Loading Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="sysfs.html">Linux Sys FileSystem Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats.html">Binary Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="ert.main.html">Embedded Runtime Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="mgmt-ioctl.main.html">XCLMGMT (PCIe Management Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="xocl_ioctl.main.html">XOCL (PCIe User Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="zocl_ioctl.main.html">ZOCL Driver Interfaces</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tools and Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xclbintools.html">xclbinutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil.html">xbutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt.html">xbmgmt</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbflash2.html">xbflash2</a></li>
<li class="toctree-l1"><a class="reference internal" href="xball.html">xball</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbtop.html">xbtop</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbtools_map.html">Utility Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="nagios_plugin.html">xrt nagios plugin</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Building Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="yocto.html">XRT Setup for Embedded Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Cloud Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mailbox.main.html">Mailbox Subdevice Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailbox.proto.html">Mailbox Inter-domain Communication Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud_vendor_support.html">MSD/MPD and Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="fpga_device_ready.html">FPGA device readiness within user VM</a></li>
<li class="toctree-l1"><a class="reference internal" href="vsec.html">Accessing vsec within VM</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Security</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="security.html">Security of Alveo Platform</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python binding</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyxrt.html">XRT Python Bindings</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Debug and Faqs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="debug-faq.html">XRT/Board Debug FAQ</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XRT</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>XRT Native APIs</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/xrt_native_apis.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <span class="target" id="xrt-native-apis-rst"></span><section id="xrt-native-apis">
<h1>XRT Native APIs<a class="headerlink" href="#xrt-native-apis" title="Permalink to this headline">¶</a></h1>
<p>From 2020.2 release XRT provides a new XRT API set in C, C++, and Python flavor.</p>
<p>To use the native XRT APIs, the host application must link with the <strong>xrt_coreutil</strong> library.
Compiling host code with XRT native C++ API requires C++ standard with -std=c++17 (or newer).</p>
<p>Example g++ command</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>g++ -g -std<span class="o">=</span>c++17 -I<span class="nv">$XILINX_XRT</span>/include -L<span class="nv">$XILINX_XRT</span>/lib -o host.exe host.cpp -lxrt_coreutil -pthread
</pre></div>
</div>
<p>The XRT native API supports both the C and C++ flavor of APIs. For general host code development, C++-based APIs are recommended, hence this document only describes the C++-based API interfaces. The full Doxygen generated C and C++ API documentation can be found in <a class="reference internal" href="xrt_native.main.html"><span class="doc">XRT Native Library C++ API</span></a>.</p>
<p>The C++ Class objects used for the APIs are</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 21%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>C++ Class</p></th>
<th class="head"><p>Header files</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Device</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::device</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_device.h&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>XCLBIN</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::xclbin</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/xrt_xclbin.h&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Buffer</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_bo.h&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Kernel</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_kernel.h&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Run</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::run</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;xrt/xrt_kernel.h&gt;</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>User-managed Kernel</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/xrt_ip.h&gt;</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Graph</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/aie.h&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/graph.h&gt;</span></code></p>
</td>
</tr>
</tbody>
</table>
<p>Majority of the core data structures are defined inside in the header files at <code class="docutils literal notranslate"><span class="pre">$XILINX_XRT/include/xrt/</span></code> directory. Few newer features such as <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::aie</span></code> related header files are inside <code class="docutils literal notranslate"><span class="pre">$XILINX_XRT/include/experimental</span></code> directory. The API interfaces that are in the experimental folder are subject to breaking changes.</p>
<p>The common host code flow using the above data structures is as below</p>
<ul class="simple">
<li><p>Open Xilinx <strong>Device</strong> and Load the <strong>XCLBIN</strong></p></li>
<li><p>Create <strong>Buffer</strong> objects to transfer data to kernel inputs and outputs</p></li>
<li><p>Use the Buffer class member functions for the data transfer between host and device (before and after the kernel execution).</p></li>
<li><p>Use <strong>Kernel</strong> and <strong>Run</strong> objects to offload and manage the compute-intensive tasks running on FPGA.</p></li>
</ul>
<p>Below we will walk through the common API usage to accomplish the above tasks.</p>
<section id="device-and-xclbin">
<h2>Device and XCLBIN<a class="headerlink" href="#device-and-xclbin" title="Permalink to this headline">¶</a></h2>
<p>Device and XCLBIN class provide fundamental infrastructure-related interfaces. The primary objective of the device and XCLBIN related APIs are</p>
<ul class="simple">
<li><p>Open a Device</p></li>
<li><p>Load compiled kernel binary (or XCLBIN) onto the device</p></li>
</ul>
<p>The simplest code to load an XCLBIN as below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">10</span><span class="w">     </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">dev_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">11</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="n">dev_index</span><span class="p">);</span><span class="w"></span>
<span class="linenos">12</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The above code block shows</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">xrt::device</span></code> class’s constructor is used to open the device (enumerated as 0)</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> is used to load the XCLBIN from the filename.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> returns the XCLBIN UUID, which is required to open the kernel (refer the Kernel Section).</p></li>
</ul>
<p>The class constructor <code class="docutils literal notranslate"><span class="pre">xrt::device::device(const</span> <span class="pre">std::string&amp;</span> <span class="pre">bdf)</span></code> also supports opening a device object from a Pcie BDF passed as a string.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">10</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="s">&quot;0000:03:00.1&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::device::get_info()</span></code> is a useful member function to obtain necessary information about a device. Some of the information such as Name, BDF can be used to select a specific device to load an XCLBIN</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">10</span><span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;device name:     &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">xrt</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">name</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
<span class="linenos">11</span><span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;device bdf:      &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">get_info</span><span class="o">&lt;</span><span class="n">xrt</span><span class="o">::</span><span class="n">info</span><span class="o">::</span><span class="n">device</span><span class="o">::</span><span class="n">bdf</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="buffers">
<h2>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h2>
<p>Buffers are primarily used to transfer the data between the host and the device. The Buffer related APIs are discussed in the following three subsections</p>
<ol class="arabic simple">
<li><p>Buffer allocation and deallocation</p></li>
<li><p>Data transfer using Buffers</p></li>
<li><p>Miscellaneous other Buffer APIs</p></li>
</ol>
<section id="buffer-allocation-and-deallocation">
<h3>1. Buffer allocation and deallocation<a class="headerlink" href="#buffer-allocation-and-deallocation" title="Permalink to this headline">¶</a></h3>
<p>The C++ interface for buffers as below</p>
<p>The class constructor <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> is mainly used to allocates a buffer object 4K aligned. By default, a regular buffer is created (optionally the user can create other types of buffers by providing a flag).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">15</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">bank_grp_arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Memory bank index for kernel argument 0</span>
<span class="linenos">16</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">bank_grp_arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Memory bank index for kernel argument 1</span>
<span class="linenos">17</span>
<span class="linenos">18</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">input_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size_in_bytes</span><span class="p">,</span><span class="n">bank_grp_arg0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">output_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">bank_grp_arg1</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In the above code <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> buffer objects are created using the class constructor. Please note the following</p>
<ul class="simple">
<li><p>As no special flags are used a regular buffer will be created. Regular buffer is most common type of buffer that has a host backing pointer allocated by user space in heap memory and a device buffer allocated in the specified memory bank.</p></li>
<li><p>The second argument specifies the buffer size.</p></li>
<li><p>The third argument is used to specify the enumerated memory bank index (to specify the buffer location) where the buffer should be allocated. There are two ways to specify the memory bank index</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>Through kernel arguments: In the above example, the <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id()</span></code> member function is used to pass the memory bank index. This member function accept kernel argument-index and automatically detect corresponding memory bank index by inspecting XCLBIN.</p></li>
<li><p>Passing Memory bank index:  The <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id()</span></code> also accepts the direct memory bank index (as observed from <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">examine</span> <span class="pre">--report</span> <span class="pre">memory</span></code> output).</p></li>
</ul>
</div></blockquote>
<section id="creating-special-buffers">
<h4>Creating special Buffers<a class="headerlink" href="#creating-special-buffers" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructors accept multiple other buffer flags those are described using <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> argument with the following enumerator values</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::normal</span></code>: Regular buffer (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::device_only</span></code>: Device only buffer (meant to be used only by the kernel, there is no host backing pointer).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::host_only</span></code>: Host only buffer (buffer resides in the host memory directly transferred to/from the kernel)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::p2p</span></code>: P2P buffer, A special type of device-only buffer capable of peer-to-peer transfer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::cacheable</span></code>: Cacheable buffer can be used when the host CPU frequently accessing the buffer (applicable for edge platform).</p></li>
</ul>
<p>The below example shows creating a P2P buffer on a device memory bank connected to argument 3 of the kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">15</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">p2p_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size_in_byte</span><span class="p">,</span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">p2p</span><span class="p">,</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="creating-buffers-from-the-user-pointer">
<h4>Creating Buffers from the user pointer<a class="headerlink" href="#creating-buffers-from-the-user-pointer" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructor can also be called using a pointer provided by the user. The user pointer must be aligned to 4K boundary.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">15</span><span class="w">     </span><span class="c1">// Host Memory pointer aligned to 4K boundary</span>
<span class="linenos">16</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">host_ptr</span><span class="p">;</span><span class="w"></span>
<span class="linenos">17</span><span class="w">     </span><span class="n">posix_memalign</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host_ptr</span><span class="p">,</span><span class="mi">4096</span><span class="p">,</span><span class="n">MAX_LENGTH</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w"></span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w">     </span><span class="c1">// Sample example filling the allocated host memory</span>
<span class="linenos">20</span><span class="w">     </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_LENGTH</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">21</span><span class="w">     </span><span class="n">host_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">  </span><span class="c1">// whatever</span>
<span class="linenos">22</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">23</span>
<span class="linenos">24</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">mybuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">host_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_LENGTH</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="data-transfer-using-buffers">
<h3>2. Data transfer using Buffers<a class="headerlink" href="#data-transfer-using-buffers" title="Permalink to this headline">¶</a></h3>
<p>XRT Buffer API library provides a rich set of APIs helping the data transfers between the host and the device, between the buffers, etc. We will discuss the following data transfer style</p>
<ol class="upperroman simple">
<li><p>Data transfer between host and device by Buffer read/write API</p></li>
<li><p>Data transfer between host and device by Buffer map API</p></li>
<li><p>Data transfer between buffers by copy API</p></li>
</ol>
<section id="i-data-transfer-between-host-and-device-by-buffer-read-write-api">
<h4>I. Data transfer between host and device by Buffer read/write API<a class="headerlink" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api" title="Permalink to this headline">¶</a></h4>
<p>To transfer the data from the host to the device, the user first needs to update the host-side buffer backing pointer followed by a DMA transfer to the device.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class has following member functions for the same functionality</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::write()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync()</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_TO_DEVICE</span></code></p></li>
</ol>
<p>To transfer the data from the device to the host, the steps are reversed, the user first needs to do a DMA transfer from the device followed by the reading data from the host-side buffer backing pointer.</p>
<p>The corresponding <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class’s member functions are</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync()</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_FROM_DEVICE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::read()</span></code></p></li>
</ol>
<p>Code example of transferring data from the host to the device</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">20</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">input_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">bank_grp_idx_0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w">     </span><span class="c1">// Prepare the input data</span>
<span class="linenos">22</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">buff_data</span><span class="p">[</span><span class="n">data_size</span><span class="p">];</span><span class="w"></span>
<span class="linenos">23</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">24</span><span class="w">         </span><span class="n">buff_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="w">     </span><span class="n">input_buffer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buff_data</span><span class="p">);</span><span class="w"></span>
<span class="linenos">28</span><span class="w">     </span><span class="n">input_buffer</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Note the C++ <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code> etc has overloaded version that can be used for partial buffer sync/read/write by specifying the size and the offset. For the above code example, the full buffer size and offset=0 are assumed as default arguments.</p>
<p>Also note that if the buffer is created through the user-pointer, the <code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code> or <code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code> is not required before or after the <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> call.</p>
</section>
<section id="ii-data-transfer-between-host-and-device-by-buffer-map-api">
<h4>II. Data transfer between host and device by Buffer map API<a class="headerlink" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrt::bo::map()</span></code> allows mapping the host-side buffer backing pointer to a user pointer. The host code can subsequently exercise the user pointer for the data reads and writes. However, after writing to the mapped pointer (or before reading from the mapped pointer) the API <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync()</span></code> should be used with direction flag for the DMA operation.</p>
<p>Code example of transferring data from the host to the device by this approach</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">20</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">input_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">bank_grp_idx_0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">21</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">input_buffer_mapped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_buffer</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">();</span><span class="w"></span>
<span class="linenos">22</span>
<span class="linenos">23</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">24</span><span class="w">         </span><span class="n">input_buffer_mapped</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="linenos">25</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">26</span>
<span class="linenos">27</span><span class="w">     </span><span class="n">input_buffer</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="iii-data-transfer-between-the-buffers-by-copy-api">
<h4>III. Data transfer between the buffers by copy API<a class="headerlink" href="#iii-data-transfer-between-the-buffers-by-copy-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy()</span></code> API for deep copy between the two buffer objects if the platform supports a deep-copy (for detail refer M2M feature described in <a class="reference internal" href="m2m.html"><span class="doc">Memory-to-Memory (M2M)</span></a>). If deep copy is not supported by the platform the data transfer happens by shallow copy (the data transfer happens via host).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">25</span><span class="w">     </span><span class="n">dst_buffer</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">src_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">copy_size_in_bytes</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy()</span></code> also has overloaded versions to provide a different offset than 0 for both the source and the destination buffer.</p>
</section>
</section>
<section id="miscellaneous-other-buffer-apis">
<h3>3. Miscellaneous other Buffer APIs<a class="headerlink" href="#miscellaneous-other-buffer-apis" title="Permalink to this headline">¶</a></h3>
<p>This section describes a few other specific use-cases using buffers.</p>
<section id="dma-buf-api">
<h4>DMA-BUF API<a class="headerlink" href="#dma-buf-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides Buffer export and import APIs primarily used for sharing buffer across devices (P2P application) and processes. The buffer handle obtained from <code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer()</span></code> is essentially a file descriptor, hence sending across the processes requires a suitable IPC mechanism (example, UDS or Unix Domain Socket) to translate the file descriptor of one process into another process.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer()</span></code>: Export the buffer to an exported buffer handle</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructor: Allocate a BO imported from exported buffer handle</p></li>
</ul>
<p>Consider the situation of exporting buffer from device 1 to device 2 (inside same host process).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">18</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">buffer_exported</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer_device_1</span><span class="p">.</span><span class="n">export_buffer</span><span class="p">();</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">buffer_device_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device_2</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_exported</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In the above example</p>
<ul class="simple">
<li><p>The buffer buffer_device_1 is a buffer allocated on device 1</p></li>
<li><p>buffer_device_1 is exported by the member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer</span></code></p></li>
<li><p>The new buffer buffer_device_2 is imported for device_2 by the constructor <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code></p></li>
</ul>
</section>
<section id="sub-buffer-support">
<h4>Sub-buffer support<a class="headerlink" href="#sub-buffer-support" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class constructor can also be used to allocate a sub-buffer from a parent buffer by specifying a start offset and the size.</p>
<p>In the example below a sub-buffer is created from a parent buffer of size 4 bytes starting from its offset 0</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">18</span><span class="w">     </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sub_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"></span>
<span class="linenos">19</span><span class="w">     </span><span class="kt">size_t</span><span class="w"> </span><span class="n">sub_buffer_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">20</span>
<span class="linenos">21</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">sub_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">parent_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">sub_buffer_size</span><span class="p">,</span><span class="w"> </span><span class="n">sub_buffer_offset</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="buffer-information">
<h4>Buffer information<a class="headerlink" href="#buffer-information" title="Permalink to this headline">¶</a></h4>
<p>XRT provides few other API Class member functions to obtain information related to the buffer.</p>
<ul class="simple">
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::size()</span></code>: Size of the buffer</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::address()</span></code> : Physical address of the buffer</p></li>
</ul>
</section>
</section>
</section>
<section id="kernel-and-run">
<h2>Kernel and Run<a class="headerlink" href="#kernel-and-run" title="Permalink to this headline">¶</a></h2>
<p>To execute a kernel on a device, a kernel class (<code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code>) object has to be created from currently loaded xclbin.  The kernel object can be used to execute the kernel function on the hardware instance (Compute Unit or CU) of the kernel.</p>
<p>A Run object (<code class="docutils literal notranslate"><span class="pre">xrt::run</span></code>) represents an execution of the kernel. Upon finishing the kernel execution, the Run object can be reused to invoke the same kernel function if desired.</p>
<p>The following topics are discussed below</p>
<ul class="simple">
<li><p>Obtaining kernel object from XCLBIN</p></li>
<li><p>Getting the bank group index of a kernel argument</p></li>
<li><p>Execution of kernel and dealing with the associated run</p></li>
<li><p>Other kernel related API</p></li>
</ul>
<section id="obtaining-kernel-object-from-xclbin">
<h3>Obtaining kernel object from XCLBIN<a class="headerlink" href="#obtaining-kernel-object-from-xclbin" title="Permalink to this headline">¶</a></h3>
<p>The kernel object is created from the device, XCLBIN UUID and the kernel name using <code class="docutils literal notranslate"><span class="pre">xrt::kernel()</span></code> constructor as shown below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">36</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">krnl</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p><strong>Note</strong>: A single kernel object (when created by a kernel name) can be used to execute multiple CUs as long as CUs are having identical interface connectivity. If all the CUs of the kernel are not having identical connectivity, XRT assigns a subset of CUs (one or more CUs with identical connectivity) to the created kernel object and discards the rest of the CUs (discarded CUs are not used during the execution of a kernel).  For this type of situation creating a kernel object using mangled CU names can be more useful.</p>
<p>As an example, assume a kernel name is foo having 3 CUs foo_1, foo_2, foo_3. The CUs foo_1 and foo_2 are connected to DDR bank 0, but the CU foo_3 is connected to DDR bank 1.</p>
<ul class="simple">
<li><p>Opening kernel object for foo_1 and foo_2 (as they have identical interface connection)</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="n">krnl_obj_1_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo:{foo_1,foo_2}&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<ul class="simple">
<li><p>Opening kernel object for foo_3</p></li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="n">krnl_obj_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo:{foo_3}&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="getting-bank-group-index-of-the-kernel-argument">
<h3>Getting bank group index of the kernel argument<a class="headerlink" href="#getting-bank-group-index-of-the-kernel-argument" title="Permalink to this headline">¶</a></h3>
<p>We have seen in the Buffer creation section that it is required to provide the buffer location during the buffer creation. The member function <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id()</span></code> returns the memory bank index (or id) of a specific argument of the kernel. This id is passed as a parameter of <code class="docutils literal notranslate"><span class="pre">xrt::bo()</span></code> constructor to create the buffer on the same memory bank.</p>
<p>Let us review the example below where the buffer is allocated for the kernel’s first (argument index 0) argument.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">15</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">input_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">buffer_size_in_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
<p>If the kernel bank index is ambiguous then <code class="docutils literal notranslate"><span class="pre">kernel.group_id()</span></code> returns the last memory bank index in the list it maintains. This is the case when the kernel has multiple CU with different connectivity for that argument. For example, let’s assume a kernel argument (argument 0) is connected to memory bank 0, 1, 2 (for 3 CUs), then <code class="docutils literal notranslate"><span class="pre">kernel.group_id(0)</span></code> will return the last index from the group {0,1,2}, i.e. 2. As a result the buffer is created on the memory bank 2, so the buffer cannot be used for the CU0 and CU1.</p>
<p>However, in the above situation, the user can always create 3 distinct kernel objects corresponds to 3 CUs (by using the <code class="docutils literal notranslate"><span class="pre">{kernel_name:{cu_name(s)}}</span></code> for xrt::kernel constructor) to execute the CUs by separate <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> objects.</p>
</section>
<section id="executing-the-kernel">
<h3>Executing the kernel<a class="headerlink" href="#executing-the-kernel" title="Permalink to this headline">¶</a></h3>
<p>Execution of the kernel is associated with a <strong>Run</strong> object. The kernel can be executed by the <code class="docutils literal notranslate"><span class="pre">xrt::kernel::operator()</span></code> that takes all the kernel arguments in order. The kernel execution API returns a run object corresponding to the execution.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">50</span><span class="w">     </span><span class="c1">// 1st kernel execution</span>
<span class="linenos">51</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kernel</span><span class="p">(</span><span class="n">buf_a</span><span class="p">,</span><span class="w"> </span><span class="n">buf_b</span><span class="p">,</span><span class="w"> </span><span class="n">scalar_1</span><span class="p">);</span><span class="w"></span>
<span class="linenos">52</span><span class="w">     </span><span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>
<span class="linenos">53</span>
<span class="linenos">54</span><span class="w">     </span><span class="c1">// 2nd kernel execution with just changing 3rd argument</span>
<span class="linenos">55</span><span class="w">     </span><span class="n">run</span><span class="p">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">scalar_2</span><span class="p">);</span><span class="w"> </span><span class="c1">// Arguments are specified starting from 0</span>
<span class="linenos">56</span><span class="w">     </span><span class="n">run</span><span class="p">.</span><span class="n">start</span><span class="p">();</span><span class="w"></span>
<span class="linenos">57</span><span class="w">     </span><span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> class provides <strong>overloaded operator ()</strong> to execute the kernel with a comma-separated list of arguments.</p>
<p>The above c++ code block is demonstrating</p>
<ul class="simple">
<li><p>The kernel execution using the <code class="docutils literal notranslate"><span class="pre">xrt::kernel()</span></code> operator with the list of arguments that returns a <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> object. This is an asynchronous API and returns after submitting the task.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code> is used to block the current thread until the current execution is finished.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg()</span></code> is used to set one or more kernel argument(s) before the next execution. In the example above, only the last (3rd) argument is changed.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start()</span></code> is used to start the next kernel execution with new argument(s).</p></li>
</ul>
</section>
<section id="other-kernel-apis">
<h3>Other kernel APIs<a class="headerlink" href="#other-kernel-apis" title="Permalink to this headline">¶</a></h3>
<p><strong>Obtaining the run object before execution</strong>: Example of the previous section shows to obtain a <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> object when the kernel is executed (kernel execution returns a run object). However, a <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> object can be obtained even before the kernel execution. The flow is as below</p>
<ul class="simple">
<li><p>Open a Run object by the <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> constructor with a kernel argument).</p></li>
<li><p>Set the kernel arguments associated for the next execution by the member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg()</span></code>.</p></li>
<li><p>Execute the kernel by the member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start()</span></code>.</p></li>
<li><p>Wait for the execution finish by the member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code>.</p></li>
</ul>
<p><strong>Timeout while wait for kernel finish</strong>: The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code> blocks the current thread until the kernel execution finishes. To specify a timeout supported API <code class="docutils literal notranslate"><span class="pre">xrt::run::wait()</span></code> also accepts a timeout in millisecond unit.</p>
</section>
</section>
<section id="user-managed-kernel">
<h2>User Managed Kernel<a class="headerlink" href="#user-managed-kernel" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> is used to execute the kernels with standard control interface through AXI-Lite control registers. These standard control interfaces are well defined and understood by XRT but transparent to the user. These XRT managed kernels should always be represented by <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> objects in the host code.</p>
<p>The XRT also supports custom control interface for a kernel. These type of kernels (a.k.a User-Managed Kernel) must be managed by the user by writing/reading to/from the AXI-Lite registers controlling these kernels. To differentiate from the XRT managed kernel, class <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> is used to specify a user-managed kernel inside the user host code.</p>
<section id="creating-xrt-ip-object-from-xclbin">
<h3>Creating <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object from XCLBIN<a class="headerlink" href="#creating-xrt-ip-object-from-xclbin" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object creation is very similar to creating a kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">36</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">ip</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ip_name&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>An ip object can only be opened in exclusive mode. That means at a time, only one thread/process can access IP at the same time. This is required for a safety reason because multiple threads/processes reading/writing to the AXI-Lite registers at the same time potentially leads to a race situation.</p>
</section>
<section id="allocating-buffers-for-the-ip-inputs-outputs">
<h3>Allocating buffers for the IP inputs/outputs<a class="headerlink" href="#allocating-buffers-for-the-ip-inputs-outputs" title="Permalink to this headline">¶</a></h3>
<p>Similar to XRT managed kernel <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> objects are used to create buffers for IP ports. However, the memory bank location must be specified explicitly by providing enumerated index of the memory bank.</p>
<p>Below is a example of creating two buffers. Note the last argument of <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> is the enumerated index of the memory bank as seen by the XRT (in this example index 8 corresponds to the host-memory bank). The bank index can be obtained by <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">examine</span> <span class="pre">--report</span> <span class="pre">memory</span></code> command.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">buf_in_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">DATA_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">host_only</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
<span class="linenos">36</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">buf_in_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">DATA_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="o">::</span><span class="n">flags</span><span class="o">::</span><span class="n">host_only</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="reading-and-write-cu-mapped-registers">
<h3>Reading and write CU mapped registers<a class="headerlink" href="#reading-and-write-cu-mapped-registers" title="Permalink to this headline">¶</a></h3>
<p>To read and write from the AXI-Lite register space to a CU (specified by <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> object in the host code), the required member functions from the <code class="docutils literal notranslate"><span class="pre">xrt::ip</span></code> class are</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::ip::read_register</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::ip::write_register</span></code></p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">read_data</span><span class="p">;</span><span class="w"></span>
<span class="linenos">36</span><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">write_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span><span class="w"></span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">ip</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;foo:{foo_1}&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="w">     </span><span class="n">read_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="p">.</span><span class="n">read_register</span><span class="p">(</span><span class="n">READ_OFFSET</span><span class="p">);</span><span class="w"></span>
<span class="linenos">41</span><span class="w">     </span><span class="n">ip</span><span class="p">.</span><span class="n">write_register</span><span class="p">(</span><span class="n">WRITE_OFFSET</span><span class="p">,</span><span class="n">write_data</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In the above code block</p>
<ul class="simple">
<li><p>The CU named “foo_1” (name syntax: “kernel_name:{cu_name}”) is opened exclusively.</p></li>
<li><p>The Register Read/Write operation is performed.</p></li>
</ul>
</section>
</section>
<section id="graph">
<h2>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">¶</a></h2>
<p>In Versal ACAPs with AI Engines, the XRT Graph class (<code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code>) and its member functions can be used to dynamically load, monitor, and control the graphs executing on the AI Engine array.</p>
<p><strong>A note regarding Device and Buffer</strong>: In AIE based application, the device and buffer have some additional functionlities. For this reason the classes <code class="docutils literal notranslate"><span class="pre">xrt::aie::device</span></code> and <code class="docutils literal notranslate"><span class="pre">xrt::aie::buffer</span></code> are recommended to specify device and buffer objects.</p>
<section id="graph-opening-and-closing">
<h3>Graph Opening and Closing<a class="headerlink" href="#graph-opening-and-closing" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code> object can be opened using the uuid of the currently loaded XCLBIN file as shown below</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">36</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">graph</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;graph_name&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The graph object can be used to execute the graph function on the AIE tiles.</p>
</section>
<section id="reset-functions">
<h3>Reset Functions<a class="headerlink" href="#reset-functions" title="Permalink to this headline">¶</a></h3>
<p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::reset()</span></code> is used to reset a specified graph by disabling tiles and enabling tile reset.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">45</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">46</span>
<span class="linenos">47</span><span class="w">     </span><span class="c1">// load XCLBIN</span>
<span class="linenos">48</span><span class="w">     </span><span class="p">...</span><span class="w"></span>
<span class="linenos">49</span>
<span class="linenos">50</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">graph</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">xclbin_uuid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;graph_name&quot;</span><span class="p">);</span><span class="w"></span>
<span class="linenos">51</span><span class="w">     </span><span class="c1">// Graph Reset</span>
<span class="linenos">52</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
<p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::aie::device::reset_array()</span></code> is used to reset the whole AIE array. But after this AIE reset functionality is called, the PDI get lost, so a special AIE only XCLBIN has be loaded (This flow is for advanced user only).</p>
</section>
<section id="graph-execution">
<h3>Graph execution<a class="headerlink" href="#graph-execution" title="Permalink to this headline">¶</a></h3>
<p>XRT provides basic graph execution control interfaces to initialize, run, wait, and terminate graphs for a specific number of iterations. Below we will review some of the common graph execution styles.</p>
<section id="graph-execution-for-a-fixed-number-of-iterations">
<h4>Graph execution for a fixed number of iterations<a class="headerlink" href="#graph-execution-for-a-fixed-number-of-iterations" title="Permalink to this headline">¶</a></h4>
<p>A graph can be executed for a fixed number of iterations followed by a “busy-wait” or a “time-out wait”.</p>
<p><strong>Busy Wait scheme</strong></p>
<p>The graph can be executed for a fixed number of iteration by <code class="docutils literal notranslate"><span class="pre">xrt::graph::run()</span></code> API using an iteration argument. Subsequently, <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait()</span></code> or <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> API should be used (with argument 0) to wait until graph execution is completed.</p>
<p>Let’s review the below example</p>
<ul>
<li><p>The graph is executed for 3 iterations by API <code class="docutils literal notranslate"><span class="pre">xrt::graph::run()</span></code> with the number of iterations as an argument.</p></li>
<li><p>The API <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(0)</span></code> is used to wait till the iteration is done.</p>
<blockquote>
<div><ul class="simple">
<li><p>The API <cite>xrt::graph::wait()</cite> is used because the host code needs to execute the graph again.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The Graph is executed again for 5 iteration</p></li>
<li><p>The API <code class="docutils literal notranslate"><span class="pre">xrt::graph::end(0)</span></code> is used to wait till the iteration is done.</p>
<blockquote>
<div><ul class="simple">
<li><p>After <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> the same graph can not be executed.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="c1">// start from reset state</span>
<span class="linenos">36</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="w">     </span><span class="c1">// run the graph for 3 iteration</span>
<span class="linenos">39</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">     </span><span class="c1">// Wait till the graph is done</span>
<span class="linenos">42</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Use graph::wait if you want to execute the graph again</span>
<span class="linenos">43</span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="linenos">46</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// Use graph::end if you are done with the graph execution</span>
</pre></div>
</div>
<p><strong>Timeout wait scheme</strong></p>
<p>As shown in the above example <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(0)</span></code> performs a busy-wait and suspend the execution till the graph is not done. If desired a timeout version of the wait can be achieved by <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(std::chrono::milliseconds)</span></code> which can be used to wait for some specified number of milliseconds, and if the graph is not done do something else in the meantime. An example is shown below</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="c1">// start from reset state</span>
<span class="linenos">36</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="w">     </span><span class="c1">// run the graph for 100 iteration</span>
<span class="linenos">39</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span><span class="w"></span>
<span class="linenos">40</span>
<span class="linenos">41</span><span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">42</span>
<span class="linenos">43</span><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">44</span><span class="w">           </span><span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="linenos">45</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">46</span><span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">().</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ETIME</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">49</span>
<span class="linenos">50</span><span class="w">              </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Timeout, reenter......&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="linenos">51</span><span class="w">              </span><span class="c1">// Do something</span>
<span class="linenos">52</span>
<span class="linenos">53</span><span class="w">           </span><span class="p">}</span><span class="w"></span>
<span class="linenos">54</span><span class="w">       </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="infinite-graph-execution">
<h4>Infinite Graph Execution<a class="headerlink" href="#infinite-graph-execution" title="Permalink to this headline">¶</a></h4>
<p>The graph runs infinitely if <code class="docutils literal notranslate"><span class="pre">xrt::graph::run()</span></code> is called with iteration argument 0. While a graph running infinitely the APIs <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait()</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::graph::suspend()</span></code> and <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> can be used to suspend/end the graph operation after some number of AIE cycles. The API <code class="docutils literal notranslate"><span class="pre">xrt::graph::resume()</span></code> is used to execute the infinitely running graph again.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="linenos">39</span><span class="w">     </span><span class="c1">// start from reset state</span>
<span class="linenos">40</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="w">     </span><span class="c1">// run the graph infinitely</span>
<span class="linenos">43</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span><span class="w">  </span><span class="c1">// Suspends the graph after 3000 AIE cycles from the previous start</span>
<span class="linenos">46</span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span><span class="w"> </span><span class="c1">// Restart the suspended graph again to run forever</span>
<span class="linenos">49</span>
<span class="linenos">50</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">suspend</span><span class="p">();</span><span class="w"> </span><span class="c1">// Suspend the graph immediately</span>
<span class="linenos">51</span>
<span class="linenos">52</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span><span class="w"> </span><span class="c1">// Restart the suspended graph again to run forever</span>
<span class="linenos">53</span>
<span class="linenos">54</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span><span class="w">  </span><span class="c1">// End the graph operation after 5000 AIE cycles from the previous start</span>
</pre></div>
</div>
<p>In the example above</p>
<ul>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::run(0)</span></code> is used to execute the graph infinitely</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait(3000)</span></code> suspends the graph after 3000 AIE cycles from the graph starts.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the graph was already run more than 3000 AIE cycles the graph is suspended immediately.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::resume()</span></code> is used to restart the suspended graph</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::suspend()</span></code> is used to suspend the graph immediately</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::end(5000)</span></code> is  ending the graph after 5000 AIE cycles from the previous graph start.</p>
<blockquote>
<div><ul class="simple">
<li><p>If the graph was already run more than 5000 AIE cycles the graph ends immediately.</p></li>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">xrt::graph::end()</span></code> eliminates the capability of rerunning the Graph (without loading PDI and a graph reset again).</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
</section>
<section id="measuring-aie-cycle-consumed-by-the-graph">
<h3>Measuring AIE cycle consumed by the Graph<a class="headerlink" href="#measuring-aie-cycle-consumed-by-the-graph" title="Permalink to this headline">¶</a></h3>
<p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::get_timestamp()</span></code> can be used to determine AIE cycle consumed between a graph start and stop.</p>
<p>Here in this example, the AIE cycle consumed by 3 iteration is calculated</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="c1">// start from reset state</span>
<span class="linenos">36</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="linenos">37</span>
<span class="linenos">38</span><span class="w">     </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">begin_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">graph</span><span class="p">.</span><span class="n">get_timestamp</span><span class="p">();</span><span class="w"></span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="w">     </span><span class="c1">// run the graph for 3 iteration</span>
<span class="linenos">41</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="linenos">42</span>
<span class="linenos">43</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">     </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">end_t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">graph</span><span class="p">.</span><span class="n">get_timestamp</span><span class="p">();</span><span class="w"></span>
<span class="linenos">46</span>
<span class="linenos">47</span><span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;Number of AIE cycles consumed in the 3 iteration is: &quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">end_t</span><span class="o">-</span><span class="n">begin_t</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="rtp-runtime-parameter-control">
<h3>RTP (Runtime Parameter) control<a class="headerlink" href="#rtp-runtime-parameter-control" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">xrt::graph</span></code> class contains member function to update and read the runtime parameters of the graph.</p>
<ul class="simple">
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::update()</span></code> to update the RTP</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::read()</span></code> to read the RTP.</p></li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span><span class="w"></span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="linenos">38</span>
<span class="linenos">39</span><span class="w">     </span><span class="kt">float</span><span class="w"> </span><span class="n">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>
<span class="linenos">40</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="s">&quot;mm.mm0.in[2]&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">increment</span><span class="p">);</span><span class="w"></span>
<span class="linenos">41</span>
<span class="linenos">42</span><span class="w">     </span><span class="c1">// Do more things</span>
<span class="linenos">43</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span><span class="w"></span>
<span class="linenos">44</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="w">     </span><span class="c1">// Read RTP</span>
<span class="linenos">47</span><span class="w">     </span><span class="kt">float</span><span class="w"> </span><span class="n">increment_out</span><span class="p">;</span><span class="w"></span>
<span class="linenos">48</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="s">&quot;mm.mm0.inout[0]&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">increment_out</span><span class="p">);</span><span class="w"></span>
<span class="linenos">49</span><span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;</span><span class="se">\n</span><span class="s"> RTP value read&lt;&lt;increment_out;</span>
</pre></div>
</div>
<p>In the above example, the member function <code class="docutils literal notranslate"><span class="pre">xrt::graph::update()</span></code> and <code class="docutils literal notranslate"><span class="pre">xrt::graph::read()</span></code> are used to update and read the RTP values respectively. Note the function arguments</p>
<ul class="simple">
<li><p>The hierarchical name of the RTP port</p></li>
<li><p>Variable to set/read the RTP</p></li>
</ul>
</section>
<section id="dma-operation-to-and-from-global-memory-io">
<h3>DMA operation to and from Global Memory IO<a class="headerlink" href="#dma-operation-to-and-from-global-memory-io" title="Permalink to this headline">¶</a></h3>
<p>The AIE buffer class <code class="docutils literal notranslate"><span class="pre">xrt::aie::bo</span></code> supports member function <code class="docutils literal notranslate"><span class="pre">xrt::aie::bo::sync()</span></code> that can be used to synchronize the buffer contents between global memory and AIE. The following code shows a sample example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">35</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">device</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">36</span>
<span class="linenos">37</span><span class="w">     </span><span class="c1">// Buffer from global memory (GM) to AIE</span>
<span class="linenos">38</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">in_bo</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">bo</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">39</span>
<span class="linenos">40</span><span class="w">     </span><span class="c1">// Buffer from AIE to global memory (GM)</span>
<span class="linenos">41</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">out_bo</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">aie</span><span class="o">::</span><span class="n">bo</span><span class="w"> </span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">42</span>
<span class="linenos">43</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">inp_bo_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in_bo</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">();</span><span class="w"></span>
<span class="linenos">44</span><span class="w">     </span><span class="k">auto</span><span class="w"> </span><span class="n">out_bo_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">out_bo</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">float</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">();</span><span class="w"></span>
<span class="linenos">45</span>
<span class="linenos">46</span><span class="w">     </span><span class="c1">// Prepare input data</span>
<span class="linenos">47</span><span class="w">     </span><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">my_float_array</span><span class="p">,</span><span class="n">my_float_array</span><span class="o">+</span><span class="n">SIZE</span><span class="p">,</span><span class="n">inp_bo_map</span><span class="p">);</span><span class="w"></span>
<span class="linenos">48</span>
<span class="linenos">49</span>
<span class="linenos">50</span><span class="w">     </span><span class="n">in_bo</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="s">&quot;in_sink&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">XCL_BO_SYNC_BO_GMIO_TO_AIE</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">51</span>
<span class="linenos">52</span><span class="w">     </span><span class="n">out_bo</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="s">&quot;out_sink&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">XCL_BO_SYNC_BO_AIE_TO_GMIO</span><span class="p">,</span><span class="w"> </span><span class="n">SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The above code shows</p>
<ul>
<li><p>Input and output buffer (<code class="docutils literal notranslate"><span class="pre">in_bo</span></code> and <code class="docutils literal notranslate"><span class="pre">out_bo</span></code>) to the graph are created and mapped to the user space</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::aie::bo::sync</span></code> is used for data transfer using the following arguments</p>
<blockquote>
<div><ul>
<li><p>The name of the GMIO ports associated with the DMA transfer</p></li>
<li><p>The direction of the buffer transfer</p>
<blockquote>
<div><ul class="simple">
<li><p>GMIO to Graph: <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_GMIO_TO_AIE</span></code></p></li>
<li><p>Graph to GMIO: <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_AIE_TO_GMIO</span></code></p></li>
</ul>
</div></blockquote>
</li>
<li><p>The size and the offset of the buffer</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</section>
</section>
<section id="xrt-error-api">
<h2>XRT Error API<a class="headerlink" href="#xrt-error-api" title="Permalink to this headline">¶</a></h2>
<p>In general, XRT APIs can encounter two types of errors:</p>
<ul class="simple">
<li><p>Synchronous error: Error can be thrown by the API itself. The host code can catch these exception and take necessary steps.</p></li>
<li><p>Asynchronous error: Errors from the underneath driver, system, hardware, etc.</p></li>
</ul>
<p>XRT provides an <code class="docutils literal notranslate"><span class="pre">xrt::error</span></code> class and its member functions to retrieve the asynchronous errors into the userspace host code. This helps to debug when something goes wrong.</p>
<ul class="simple">
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt::error::get_error_code()</span></code> - Gets the last error code and its timestamp of a given error class</p></li>
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt::error::get_timestamp()</span></code> - Gets the timestamp of the last error</p></li>
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt:error::to_string()</span></code> - Gets the description string of a given error code.</p></li>
</ul>
<p><strong>NOTE</strong>: The asynchronous error retrieving APIs are at an early stage of development and only supports AIE related asynchronous errors. Full support for all other asynchronous errors is planned in a future release.</p>
<p>Example code</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="w">     </span><span class="n">graph</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">runInteration</span><span class="p">);</span><span class="w"></span>
<span class="linenos">42</span>
<span class="linenos">43</span><span class="w">     </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">44</span><span class="w">        </span><span class="n">graph</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span><span class="w"></span>
<span class="linenos">45</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
<span class="linenos">46</span><span class="w">     </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">().</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ETIME</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">49</span><span class="w">           </span><span class="n">xrt</span><span class="o">::</span><span class="n">error</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">XRT_ERROR_CLASS_AIE</span><span class="p">);</span><span class="w"></span>
<span class="linenos">50</span>
<span class="linenos">51</span><span class="w">           </span><span class="k">auto</span><span class="w"> </span><span class="n">errCode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">get_error_code</span><span class="p">();</span><span class="w"></span>
<span class="linenos">52</span><span class="w">           </span><span class="k">auto</span><span class="w"> </span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">get_timestamp</span><span class="p">();</span><span class="w"></span>
<span class="linenos">53</span><span class="w">           </span><span class="k">auto</span><span class="w"> </span><span class="n">err_str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">error</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span><span class="w"></span>
<span class="linenos">54</span>
<span class="linenos">55</span><span class="w">           </span><span class="cm">/* code to deal with this specific error */</span><span class="w"></span>
<span class="linenos">56</span><span class="w">           </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">err_str</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
<span class="linenos">57</span><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">58</span><span class="w">         </span><span class="cm">/* Something else */</span><span class="w"></span>
<span class="linenos">59</span><span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="linenos">60</span><span class="w">     </span><span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The above code shows</p>
<ul class="simple">
<li><p>After timeout occurs from <code class="docutils literal notranslate"><span class="pre">xrt::graph::wait()</span></code> the member functions <code class="docutils literal notranslate"><span class="pre">xrt::error</span></code> class are called to retrieve asynchronous error code and timestamp</p></li>
<li><p>Member function <code class="docutils literal notranslate"><span class="pre">xrt::error::to_string()</span></code> is called to obtain the error string.</p></li>
</ul>
</section>
<section id="asynchornous-programming-with-xrt-experimental">
<h2>Asynchornous Programming with XRT (experimental)<a class="headerlink" href="#asynchornous-programming-with-xrt-experimental" title="Permalink to this headline">¶</a></h2>
<p>From the 22.1 release, XRT offers a simple asynchronous programming mechanism through the user-defined queues. The <code class="docutils literal notranslate"><span class="pre">xrt::queue</span></code> is lightweight, general-purpose queue implementation which is completely separated from core XRT native API data structures. If needed, the user can also use their own queue implementation instead of the implementation offered by <code class="docutils literal notranslate"><span class="pre">xrt::queue</span></code>.</p>
<p>XRT queue implementation needs <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;experimental/xrt_queue.h</span></code> to be added as the header file. The implementation also use C++17 features so the host code must be compiled with <code class="docutils literal notranslate"><span class="pre">g++</span> <span class="pre">-std=c++17</span></code></p>
<p>As a premise, by default, all XRT native APIs execute from the host-thread, so if an API has synchronous behavior the host-thread blocks until that task is finished. For example</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>As <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> is a synchronous API, the host thread blocks until its completion.</p>
<p>XRT defines a queue with <code class="docutils literal notranslate"><span class="pre">xrt::queue</span></code> with the following properties</p>
<blockquote>
<div><ul>
<li><p>Any task enqueued on the queue runs parallel to the original host-thread. So the host threads does not wait for its completion and can do other tasks in parallel.</p></li>
<li><p>The task enqueued on the queue must be synchronous in nature</p></li>
<li><p>All the tasks enqueued on the queue will be completed in the order it is enqueued (strict in-order execution).</p></li>
<li><p>The task enqueued on a queue can be any C++ Callable, which can conveniently be expressed by a C++ lambda</p></li>
<li><p>When a synchronous task is enqueued on a queue, an event (<code class="docutils literal notranslate"><span class="pre">xrt::queue:event</span></code>) is returned. The event can be used for multiple purposes, such as:</p>
<blockquote>
<div><ul class="simple">
<li><p>The host-thread can wait on that event to synchronize with the <code class="docutils literal notranslate"><span class="pre">queue::enqueue(task)</span></code> from where the event was generated.</p></li>
<li><p>The event can be enqueued to other queues to synchronize among the queues</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
<p>Let’s understand the above properties by reviewing the examples below</p>
<section id="executing-synchronous-task-asynchronously">
<h3>Executing synchronous task asynchronously<a class="headerlink" href="#executing-synchronous-task-asynchronously" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">bo0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">vector_size_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">krnl</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="linenos">42</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">bo0_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bo0</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="n">dtype</span><span class="o">*&gt;</span><span class="p">();</span><span class="w"></span>
<span class="linenos">43</span><span class="w">    </span><span class="p">....</span><span class="w"> </span><span class="c1">// fill buffer content</span>
<span class="linenos">44</span>
<span class="linenos">45</span><span class="w">    </span><span class="n">xrt</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">my_queue</span><span class="p">;</span><span class="w"></span>
<span class="linenos">46</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">sync_event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo0</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">47</span>
<span class="linenos">48</span><span class="w">    </span><span class="n">myCpuTask</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">  </span><span class="c1">// here we can perform other host task that will run parallel to the above bo::sync task</span>
<span class="linenos">49</span>
<span class="linenos">50</span><span class="w">    </span><span class="n">sync_event</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w">  </span><span class="c1">// stall the host-thread till sync operation completes</span>
</pre></div>
</div>
<p>The above code shows the synchronous API <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> is enqueued through an <code class="docutils literal notranslate"><span class="pre">xrt::queue</span></code>. The argument of xrt::queue is unnamed callable written using C++ lambda capturing buffer object. This technique is useful to execute any synchronous task asynchronously from the host-thread, and while this task is ongoing, the host-thread can do other operation in parallel (<code class="docutils literal notranslate"><span class="pre">myCpuTask()</span></code> in the above code). The return type of <code class="docutils literal notranslate"><span class="pre">xrt::queue::enqueue()</span></code> is type of <code class="docutils literal notranslate"><span class="pre">xrt::queue::event</span></code> which is later synchronized to the host-thread by <code class="docutils literal notranslate"><span class="pre">xrt::queue::event::wait()</span></code> blocking function.</p>
</section>
<section id="executing-multiple-tasks-through-queue">
<h3>Executing multiple tasks through queue<a class="headerlink" href="#executing-multiple-tasks-through-queue" title="Permalink to this headline">¶</a></h3>
<p>Every new <code class="docutils literal notranslate"><span class="pre">xrt::queue</span></code> can be thought of as a new thread running parallel to the host-thread executing a series of synchronous tasks following the order they were submitted (enqueued) on the queue. For example, let’s consider tasks A, B, C and D as below</p>
<blockquote>
<div><ul class="simple">
<li><p>Task A: Host to device data transfer (buffer bo0)</p></li>
<li><p>Task B: Execute the kernel and wait for the kernel to finish execution</p></li>
<li><p>Task C: Device to host data transfer (buffer bo_out)</p></li>
<li><p>Task D: Check return data bo_out</p></li>
</ul>
</div></blockquote>
<p>The above four tasks should be executed in-order for correct functionality. To execute them in parallel to the host-thread, these four tasks can be enqueued through a queue as below.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="w">    </span><span class="n">xrt</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">queue</span><span class="p">;</span><span class="w"></span>
<span class="linenos">42</span><span class="w">    </span><span class="n">queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo0</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">43</span><span class="w">    </span><span class="n">queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">run</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">run</span><span class="p">.</span><span class="n">start</span><span class="p">();</span><span class="w"> </span><span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">44</span><span class="w">    </span><span class="n">queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo_out</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo_out</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_FROM_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">45</span><span class="w">    </span><span class="n">queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo_out_map</span><span class="p">]{</span><span class="n">my_function_to_check_data</span><span class="p">(</span><span class="n">bo_out_map</span><span class="p">)});</span><span class="w"></span>
</pre></div>
</div>
<p>The user can create and use as many queues in the host code to overlap tasks in parallel. Next, we will see how it is possible to synchronize among the queues using the event.</p>
</section>
<section id="using-events-to-synchronize-among-the-queues">
<h3>Using events to synchronize among the queues<a class="headerlink" href="#using-events-to-synchronize-among-the-queues" title="Permalink to this headline">¶</a></h3>
<p>Let’s assume in the above example, it is required to do two host-to-device buffer transfers before the kernel execution. If using a single queue the code would appear as</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="w">    </span><span class="n">xrt</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">main_queue</span><span class="p">;</span><span class="w"></span>
<span class="linenos">42</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo0</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">43</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo1</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">44</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">run</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">run</span><span class="p">.</span><span class="n">start</span><span class="p">();</span><span class="w"> </span><span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">45</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo_out</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo_out</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_FROM_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>In the above code, as a single queue (<code class="docutils literal notranslate"><span class="pre">main_queue</span></code>) is used, the host-to-device data transfers for buffer <code class="docutils literal notranslate"><span class="pre">bo0</span></code> and <code class="docutils literal notranslate"><span class="pre">bo1</span></code> would happen sequentially. In order to do parallel data transfer for <code class="docutils literal notranslate"><span class="pre">bo0</span></code> and <code class="docutils literal notranslate"><span class="pre">bo1</span></code>, a separate queue is needed for one of the buffers, and also it is required to ensure that the kernel executes only after both the buffer transfers are completed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="linenos">41</span><span class="w">    </span><span class="n">xrt</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">main_queue</span><span class="p">;</span><span class="w"></span>
<span class="linenos">42</span><span class="w">    </span><span class="n">xrt</span><span class="o">::</span><span class="n">queue</span><span class="w"> </span><span class="n">queue_bo1</span><span class="p">;</span><span class="w"></span>
<span class="linenos">43</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo0</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo0</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">44</span><span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">bo1_event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">queue_bo1</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo1</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo1</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">45</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">bo1_event</span><span class="p">);</span><span class="w"></span>
<span class="linenos">46</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">run</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">run</span><span class="p">.</span><span class="n">start</span><span class="p">();</span><span class="w"> </span><span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="linenos">47</span><span class="w">    </span><span class="n">main_queue</span><span class="p">.</span><span class="n">enqueue</span><span class="p">([</span><span class="o">&amp;</span><span class="n">bo_out</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="n">bo_out</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_FROM_DEVICE</span><span class="p">);</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
<p>In line number 43 and 44 <code class="docutils literal notranslate"><span class="pre">bo0</span></code> and <code class="docutils literal notranslate"><span class="pre">bo1</span></code> host-to-device data transfers are enqueued through two separate queues to achieve parallel transfers. To synchronize between these two queues the returned event from the <code class="docutils literal notranslate"><span class="pre">queue_bo1</span></code> is enqueued in the <code class="docutils literal notranslate"><span class="pre">main_queue</span></code>, similar to a task enqueue (line 45). As a result, any other task submitted after that event won’t execute until the event is finished. So in the above code example, subsequent task in the <code class="docutils literal notranslate"><span class="pre">main_queue</span></code> (such as kernel execution) would wait till the <code class="docutils literal notranslate"><span class="pre">bo1_event</span></code> is completed. By submitting an event returned from a <code class="docutils literal notranslate"><span class="pre">queue::enqueue</span></code> to another queue, we can synchronize among the queues.</p>
</section>
</section>
</section>


           </div>
          </div>
          
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
				  
				  <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="opencl_extension.html" class="btn btn-neutral float-left" title="Xilinx OpenCL extension" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="xrt_native.main.html" class="btn btn-neutral float-right" title="XRT Native Library C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2023, Advanced Micro Devices, Inc.
      <span class="lastupdated">Last updated on October 7, 2022.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>