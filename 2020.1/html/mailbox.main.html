

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mailbox Subdevice Driver &mdash; XRT 2020.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Mailbox Inter-domain Communication Protocol" href="mailbox.proto.html" />
    <link rel="prev" title="Yocto Recipes For Embedded Flow" href="yocto.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> XRT
          

          
          </a>

          
            
            
              <div class="version">
                2020.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">Platform Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building and Installing Software Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Use Model and Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="execution-model.html">Execution Model Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_kernel_executions.html">Supported Kernel Execution Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocess.html">Multi-Process Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2p.html">PCIe Peer-to-Peer (P2P) Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="m2m.html">Memory-to-Memory (M2M) Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="streaming_data_support.html">XRT Streaming Platform Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_ini.html">Configuration File xrt.ini</a></li>
</ul>
<p class="caption"><span class="caption-text">Video Acceleration Using XMA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xma_user_guide.html">Xilinx Media Accelerator (XMA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_19.2.html">XMA 19.2 Migration</a></li>
</ul>
<p class="caption"><span class="caption-text">User API Library</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xrt.main.html">XRT Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="ert.main.html">Embedded Runtime Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma.main.html">XMA Core Library</a></li>
</ul>
<p class="caption"><span class="caption-text">XRT Developer's Space</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sysfs.html">Linux Sys FileSystem Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats.html">Binary Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="mgmt-ioctl.main.html">XCLMGMT (PCIe Management Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="xocl_ioctl.main.html">XOCL (PCIe User Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="zocl_ioctl.main.html">ZOCL Driver Interfaces</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools and Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xclbintools.html">xclbinutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil.html">xbutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt.html">xbmgmt</a></li>
</ul>
<p class="caption"><span class="caption-text">Building Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="yocto.html">Yocto Recipes For Embedded Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Cloud Support</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Mailbox Subdevice Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailbox.proto.html">Mailbox Inter-domain Communication Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud_vendor_support.html">MSD/MPD and Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Security</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="security.html">Security of Alveo Platform</a></li>
</ul>
<p class="caption"><span class="caption-text">Debug and Faqs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="debug-faq.html">XRT/Board Debug FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XRT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Mailbox Subdevice Driver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/mailbox.main.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mailbox-subdevice-driver">
<span id="mailbox-main-rst"></span><h1>Mailbox Subdevice Driver<a class="headerlink" href="#mailbox-subdevice-driver" title="Permalink to this headline">Â¶</a></h1>
<p><strong>Statement of Theory</strong></p>
<p>This is the mailbox sub-device driver added into existing xclmgmt / xocl
driver so that user pf and mgmt pf can send and receive messages of
arbitrary length to / from the peer. The driver is written based on the
spec of pg114 document (<a class="reference external" href="https://www.xilinx.com/support/documentation/">https://www.xilinx.com/support/documentation/</a>
ip_documentation/mailbox/v2_1/pg114-mailbox.pdf). The HW provides one TX
channel and one RX channel, which operate completely independent of each
other. Data can be pushed into or read from a channel in DWORD unit as a
FIFO.</p>
<p>Packet layer</p>
<p>The driver implemented two transport layers - packet and message layer (see
below). A packet is a fixed size chunk of data that can be sent through TX
channel or retrieved from RX channel. The TX and RX interrupt happens at
packet boundary, instead of DWORD boundary. The driver will not attempt to
send next packet until the previous one is read by peer. Similarly, the
driver will not attempt to read the data from HW until a full packet has been
written to HW by peer. In normal operational mode, data transfer is entirely
interrupt driven. So, the interrupt functionality needs to work and enabled
on both mgmt and user pf for mailbox driver to function properly. During hot
reset of the device, this driver may work in polling mode for short period of
time until the reset is done.</p>
<p>A packet is defined as struct mailbox_pkt. There are mainly two types of
packets: start-of-msg and msg-body packets. Both can carry end-of-msg flag to
indicate that the packet is the last one in the current msg.</p>
<p>The start-of-msg packet contains some meta data related to the entire msg,
such as msg ID, msg flags and msg size. Strictly speaking, these info belongs
to the msg layer, but it helps the receiving end to prepare buffer for the
incoming msg payload after seeing the 1st packet instead of the whole msg.
It is an optimization for msg receiving.</p>
<p>The body-of-msg packet contains only msg payload.</p>
<p>Message layer</p>
<p>A message is a data buffer of arbitrary length. The driver will break a
message into multiple packets and transmit them to the peer, which, in turn,
will assemble them into a full message before itâs delivered to upper layer
for further processing. One message requires at least one packet to be
transferred to the peer (a start-of-msg packet with end-of-msg flag).</p>
<p>Each message has a unique temporary u64 ID (see communication model below
for more detail). The ID shows up in start-of-msg packet only. So, at packet
layer, there is an assumption that adjacent packets belong to the same
message unless the next one is another start-of-msg packet. So, at message
layer, the driver will not attempt to send the next message until the
transmitting of current one is done. I.E., we implement a FIFO for message
TX channel. All messages are sent by driver in the order of received from
upper layer. We can implement msgs of different priority later, if needed.</p>
<p>On the RX side, there is no certain order for receiving messages. Itâs up to
the peer to decide which message gets enqueued into its own TX queue first,
which will be received first on the other side.</p>
<p>A TX message is considered as timeâd out when itâs transmit is not done
within 2 seconds (for msg larger than 1MB, itâs 2 second per MB). A RX msg
is considered as timeâd out 20 seconds after the corresponding TX one has
been sent out. There is no retry after msg timeâd out. The error will be
simply propagated back to the upper layer.</p>
<p>A msg is defined as struct mailbox_msg. It carrys a flag indicating that if
itâs a msg of request or response msg. A response msg must have a big enough
msg buffer sitting in the receiverâs RX queue waiting for it. A request msg
does not have a waiting msg buffer.</p>
<p>The upper layer can choose to queue a message for TX or RX asynchronously
when it provides a callback or wait synchronously when no callback is
provided.</p>
<p>Communication layer</p>
<p>At the highest layer, the driver implements a request-response communication
model. Three types of msgs can be sent/received in this model:</p>
<ul class="simple">
<li>A request msg which requires a response.</li>
<li>A notification msg which does not require a response.</li>
<li>A response msg which is used to respond a request.</li>
</ul>
<p>The OP code of the request determines whether itâs a request or notification.</p>
<p>If provided, a response msg must match a request msg by msg ID, or itâll be
silently dropped. And there is no response to a reponse. A communication
session starts with a request and finishes with 0 or 1 reponse, always.
A request buffer or response buffer will be wrapped with a single msg. This
means that a session contains at most 2 msgs and the msg ID serves as the
session ID.</p>
<p>The mailbox driver provides a few kernel APIs for mgmt and user pf to talk to
each other at this layer (see mailbox_ops for details). A request or
notification msg will automatically be assigned a msg ID when itâs enqueued
into TX channel for transmitting. For a request msg, the buffer provided by
caller for receiving response will be enqueued into RX channel as well. The
enqueued response msg will have the same msg ID as the corresponding request
msg. The response msg, if provided, will always be enqueued before the
request msg is enqueued to avoid race condition.</p>
<p>When a new request or notification is received from peer, driver will
allocate a msg buffer and copy the msg into it then passes it to the callback
provided by upper layer (mgmt or user pf driver) through <code class="xref c c-func docutils literal notranslate"><span class="pre">xocl_peer_listen()</span></code>
API for further processing.</p>
<p>Currently, the driver implements one kernel thread for RX channel (RX thread)
, one for TX channel (TX thread) and one thread for processing incoming
request (REQ thread).</p>
<p>The RX thread is responsible for receiving incoming msgs. If itâs a request
or notification msg, itâll punt it to REQ thread for processing, which, in
turn, will call the callback provided by mgmt pf driver
(<code class="xref c c-func docutils literal notranslate"><span class="pre">xclmgmt_mailbox_srv()</span></code>) or user pf driver (<code class="xref c c-func docutils literal notranslate"><span class="pre">xocl_mailbox_srv()</span></code>) to further
process it. If itâs a response, itâll simply wake up the waiting thread (
currently, all response msgs are waited synchronously by caller)</p>
<p>The TX thread is responsible for sending out msgs. When itâs done, the TX
thread will simply wake up the waiting thread (if itâs a request requiring
a response) or call a default callback to free the msg when the msg is a
notification or a response msg which does not require any response.</p>
<p>Software communication channel</p>
<p>A msg can be sent or received through HW mailbox channel or through a daemon
implemented in user land (software communication daemon). The daemon waiting
for sending msg from user pf to mgmt pf is called MPD. The other one is MSD,
which is responsible for sending msg from mgmt pf to user pf.</p>
<p>Each mailbox subdevice driver creates a device node under /dev. A daemon
(MPD or MSD) can block and wait in the <code class="xref c c-func docutils literal notranslate"><span class="pre">read()</span></code> interface waiting for fetching
out-going msg sent to peer. Or it can block and wait in the <code class="xref c c-func docutils literal notranslate"><span class="pre">poll()</span></code>/<code class="xref c c-func docutils literal notranslate"><span class="pre">select()</span></code>
interface and will be woken up when there is an out-going msg ready to be
sent. Then it can fetch the msg via <code class="xref c c-func docutils literal notranslate"><span class="pre">read()</span></code> interface. Itâs entirely up to the
daemon to process the msg. It may pass it through to the peer or handle it
completely in its own way.</p>
<p>If the daemon wants to pass a msg (request or response) to a mailbox driver,
it can do so by calling <code class="xref c c-func docutils literal notranslate"><span class="pre">write()</span></code> driver interface. It may block and wait until
the previous msg is consumed by the RX thread before it can finish
transmiting its own msg and return back to user land.</p>
<p>The interface between daemons and mailbox is defined as struct sw_chan. Refer
to mailbox_proto.h for details.</p>
<p>Communication protocols</p>
<p>As indicated above, the packet layer and msg layer communication protocol is
defined as struct mailbox_pkt and struct mailbox_msg respectively in this
file. The protocol for communicating at communication layer is defined in
mailbox_proto.h.</p>
<p>The software communication channel communicates at communication layer only,
which sees only request and response buffers. It should only implement the
protocol defined in mailbox_proto.h.</p>
<p>The current protocol defined at communication layer followed a rule as below:
All requests initiated from user pf requires a response and all requests from
mgmt pf does not require a response. This should avoid any possible deadlock
derived from each side blocking and waiting for response from the peer.</p>
<p>The overall architecture can be shown as below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>      +----------+      +----------+            +----------+
      [ Req/Resp ]  &lt;---[SW Channel]----&gt;       [ Req/Resp ]
+-----+----------+      +----------+      +-----+----------+
[ Msg | Req/Resp ]                        [ Msg | Req/Resp ]
+---+-+------+---+      +----------+      +---+-+-----+----+
[Pkt]...[]...[Pkt]  &lt;---[HW Channel]----&gt; [Pkt]...[]...[Pkt]
+---+        +---+      +----------+      +---+        +---+
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="mailbox.proto.html" class="btn btn-neutral float-right" title="Mailbox Inter-domain Communication Protocol" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="yocto.html" class="btn btn-neutral float-left" title="Yocto Recipes For Embedded Flow" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020, Xilinx, Inc

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>