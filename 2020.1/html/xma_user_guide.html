

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Xilinx Media Accelerator (XMA) &mdash; XRT 2020.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="XMA 19.2 Migration" href="xma_19.2.html" />
    <link rel="prev" title="Configuration File xrt.ini" href="xrt_ini.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> XRT
          

          
          </a>

          
            
            
              <div class="version">
                2020.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">Platform Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building and Installing Software Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Use Model and Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="execution-model.html">Execution Model Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_kernel_executions.html">Supported Kernel Execution Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocess.html">Multi-Process Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2p.html">PCIe Peer-to-Peer (P2P) Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="m2m.html">Memory-to-Memory (M2M) Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="streaming_data_support.html">XRT Streaming Platform Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_ini.html">Configuration File xrt.ini</a></li>
</ul>
<p class="caption"><span class="caption-text">Video Acceleration Using XMA</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Xilinx Media Accelerator (XMA)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xma-application-interface-overview">XMA Application Interface Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xma-plugin-interface-overview">XMA Plugin Interface Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sequence-of-operations">Sequence of Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#execution-model">Execution model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#application-development-guide">Application Development Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initialization">Initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-session">Create Session</a></li>
<li class="toctree-l3"><a class="reference internal" href="#runtime-frame-and-data-processing">Runtime Frame and Data Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cleanup">Cleanup</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#plugin-development-guide">Plugin Development Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#initalization">Initalization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#handling-incoming-application-data">Handling Incoming Application Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sending-output-to-the-application">Sending Output to the Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="#termination">Termination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zerocopy-special-case">Zerocopy Special Case</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="xma_19.2.html">XMA 19.2 Migration</a></li>
</ul>
<p class="caption"><span class="caption-text">User API Library</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xrt.main.html">XRT Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="ert.main.html">Embedded Runtime Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma.main.html">XMA Core Library</a></li>
</ul>
<p class="caption"><span class="caption-text">XRT Developer's Space</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sysfs.html">Linux Sys FileSystem Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats.html">Binary Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="mgmt-ioctl.main.html">XCLMGMT (PCIe Management Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="xocl_ioctl.main.html">XOCL (PCIe User Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="zocl_ioctl.main.html">ZOCL Driver Interfaces</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools and Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xclbintools.html">xclbinutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil.html">xbutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt.html">xbmgmt</a></li>
</ul>
<p class="caption"><span class="caption-text">Building Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="yocto.html">Yocto Recipes For Embedded Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Cloud Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mailbox.main.html">Mailbox Subdevice Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailbox.proto.html">Mailbox Inter-domain Communication Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud_vendor_support.html">MSD/MPD and Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Security</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="security.html">Security of Alveo Platform</a></li>
</ul>
<p class="caption"><span class="caption-text">Debug and Faqs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="debug-faq.html">XRT/Board Debug FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XRT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Xilinx Media Accelerator (XMA)</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/xma_user_guide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xilinx-media-accelerator-xma">
<h1>Xilinx Media Accelerator (XMA)<a class="headerlink" href="#xilinx-media-accelerator-xma" title="Permalink to this headline">Â¶</a></h1>
<p>Major XMA Changes in 2019.2 Release:</p>
<ol class="arabic simple">
<li>YAML configuration file is not used by XMA</li>
<li>Resource management is not handled by XMA<ol class="loweralpha">
<li>So channel_id for multi-channel kernels must be handled in host video application (like ffmpeg)</li>
<li>channel_id is input to XMA in session_create API as part of the properties argument</li>
<li>See XRM for resource management details</li>
</ol>
</li>
<li>MPSoC PL &amp; soft kernels are supported in XMA</li>
<li>Direct register read &amp; write is not available</li>
<li>DataFlow kernels are supported</li>
<li>ZeroCopy support has changed. See below for details</li>
<li>BufferObject added. See below for details</li>
<li>XmaFrame &amp; XmaDataBuffer can use device buffers instead of host only memory</li>
<li>Support for device_only buffers</li>
<li>Session creation &amp; destroy APIs are thread safe now</li>
<li>Multi-process support is from XRT</li>
<li>schedule_work_item  API changed to return CUCmdObj</li>
<li>New API xma_plg_schedule_cu_cmd &amp; xma_plg_cu_cmd_status can be used instead of schedule_work_item</li>
<li>In a session if using xma_plg_cu_cmd_status then do NOT use xma_plg_is_work_item_done in same session</li>
<li>Supports up to 128 CUs per device</li>
<li>CU register map size &lt; 4KB</li>
<li>By default XMA will automatically select default ddr bank for new device buffers (as per selected CU). Session_create may provide user selected default ddr bank input when XMA will use user select default ddr bank for plugin with that session</li>
<li>For using ddr bank other than default session ddr_bank use APIs xma_plg_buffer_alloc_arg_num(). See below for info</li>
<li>XMA now support multiple ddr bank per plugin. See below for info on xma_plg_buffer_alloc_arg_num()</li>
<li>XMA version check API added to plugin struct. See below for details</li>
<li>New session type XMA_ADMIN for non-video applications to control multiple CUs in single session. See below for details</li>
<li>get_session_cmd_load(): Get CU command load of various sessions relative to each other. Printed to log file</li>
<li>CU command load of all session is automatically sent to log file at end of the application</li>
<li>This gives info on which sessions (or CUs) are more busy compared to other sessions (or CUs)</li>
<li>QDMA platform: Host to kernel streams will be supported by XMA in future. See below for more details</li>
</ol>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">Â¶</a></h2>
<p>The Xilinx Media Accelerator (XMA) library (libxmaapi) is a host interface
meant to simplify the development of applications managing and controlling
video accelerators such as decoders, scalers, filters, and encoders. The
libxmaapi is comprised of two API interfaces: an application interface and a
plugin interface. The application API is a higher-level, generalized
interface intended for application developers responsible for integrating
control of Xilinx accelerators into software frameworks such as FFmpeg,
GStreamer, or proprietary frameworks. The plugin API is a lower level
interface intended for developers responsible for implementing hardware
control of specific Xilinx acceleration kernels. In general, plugins are
developed by kernel providers as these plugins are specialized user space
drivers that are aware of the low-level hardware interface.</p>
<p>From a high-level perspective, the XMA sits between a media framework (i.e.
FFmpeg)  and the Xilinx runtime (XRT). In addition, the XMA acts as a peer
to the host side implementation of OpenCL. The diagram below illustrates the
entire stack including an example of common accelerator kernels that are
possible in a specific design:</p>
<img alt="_images/XMA-Stack.png" class="align-center" src="_images/XMA-Stack.png" />
<p>The remaining sections will describe the key architectural aspects of the
libxmaapi and describe the high-level API along with the low-level plugin
API.</p>
</div>
<div class="section" id="xma-application-interface-overview">
<h2>XMA Application Interface Overview<a class="headerlink" href="#xma-application-interface-overview" title="Permalink to this headline">Â¶</a></h2>
<p>The API for the libxmaapi can be categorized into three areas:</p>
<ol class="arabic simple">
<li>Initialization</li>
<li>Video frame processing</li>
<li>Termination</li>
</ol>
<p>From an interface perspective, the high-level or upper edge interface and the
low-level or plugin interface are organized as follows:</p>
<img alt="_images/XMA-Internal-Stack.png" class="align-center" src="_images/XMA-Internal-Stack.png" />
<p>The diagram above illustrates a number of distinct API layers.  The XMA upper
edge initialization API provides two types of initialization: global and
session level initialization.  The XMA upper edge API also provides functions
for sending and receiving frames as well as a method for gracefully terminating
a video stream when the end of the stream is found.  Also depicted in the
diagram is the XMA Framework.  The XMA Framework is responsible for
delegating requests to the appropriate plugin, and selecting user requested
resources based on session creation requests.</p>
<p>See the <a class="reference internal" href="#application-development-guide">Application Development Guide</a> for more information about utilizing the XMA
application interface to development your own stand alone or integrated
applications.</p>
</div>
<div class="section" id="xma-plugin-interface-overview">
<h2>XMA Plugin Interface Overview<a class="headerlink" href="#xma-plugin-interface-overview" title="Permalink to this headline">Â¶</a></h2>
<p>The XMA lower edge API parallels the upper edge API; however, the lower edge
API is comprised of function callbacks similar to those used in a driver or as
defined in the FFmpeg plugin interface.</p>
<p>There are five classes of XMA plugin interfaces: decoders, encoders,
filters, scalers, and a generic âkernelâ class.
Since each of these classes are unique in terms of the processing performed,
the APIs are slightly different, however, there is a common pattern associated
with these classes. Specifically, a plugin must provide registration
information and must implement all required callback functions. In general, an
XMA plugin implements at least five required callback functions: initialize,
send frame or send data, receive frame or receive data, close and xma_version.</p>
<p>BufferObject:</p>
<ol class="arabic simple">
<li>uint8_t* data : Pointer to host buffer space of allocated buffer</li>
<li>uint64_t size: Size of allocated buffer</li>
<li>uint64_t paddr:
a. FPGA DDR Addr of allocated buffer.
b. Use it to pass DDR addr to CUs as part of regmap with xma_plg_schedule_cu_cmd or xma_plg_schedule_work_item API</li>
<li>int32_t  bank_index: DDR bank index</li>
<li>int32_t  dev_index: FPGA device index on which the buffer is allocated</li>
<li>bool     device_only_buffer: If it is device only buffer.</li>
<li>For device only buffers, BufferObject â data == NULL as no host buffer space is allocated</li>
<li>ref_cnt &amp; user_ptr: For plugin/user to use</li>
</ol>
<p>XmaFrame &amp; XmaDataBuffer with device buffers:</p>
<ol class="arabic simple">
<li>xma_frame_from_device_buffers()</li>
<li>xma_data_from_device_buffer()</li>
</ol>
<p>ZeroCopy use cases:</p>
<ol class="arabic simple">
<li>Use XRM for system resource reservation such that zero-copy is possible</li>
<li>XmaFrame with device only buffer can be output of plugins supporting zero-copy and feeding zero-copy enabled plugin/s</li>
<li>Plugins may use dev_index, bank_index &amp; device_only info from BufferObject to enable or disable zero-copy</li>
</ol>
<p>ZeroCopy trancode pipeline:</p>
<ol class="arabic simple">
<li>Decoder-&gt;Scaler-&gt;Encoder</li>
<li>FFMPEG completes xma_init &amp; create session for all plugins</li>
<li>Pass zerocopy settings for plugins to use</li>
<li>FFMPEG â&gt; send_data with host buffer â&gt; decoder plugin</li>
<li>Decoder plugin uses device buffers for input &amp; output of kernel. Decoder has pool of device buffers to use. Decoder plugin does buffer write to DMA data to FPGA</li>
<li>FFMPEG â&gt; receive frame with DUMMY frame â&gt; decoder plugin</li>
<li>Decoder plugin adds output device buffer to the frame: xma_plg_add_buffer_to_frame()</li>
<li>FFMPEG â&gt; send frame to scaler - same as received from decoder with device buffer</li>
<li>Scaler plugin uses device buffer from input frame as itâs input &amp; uses an output buffer from itâs pool of buffers</li>
<li>FFMPEG â&gt; receive frame with DUMMY frame â&gt; scaler plugin</li>
<li>Scaler plugin adds output device buffer to the frame: xma_plg_add_buffer_to_frame()</li>
<li>FFMPEG â&gt; send frame to encoder - same as received from scaler with device buffer</li>
<li>Encoder plugin uses device buffer from input frame as itâs input &amp; uses an output buffer from itâs pool of buffers</li>
<li>FFMPEG â&gt; receive frame with DUMMY DataBuffer â&gt; encoder plugin</li>
<li>Encoder plugin adds output device buffer to the DataBuffer: xma_plg_add_buffer_to_data_buffer(). Encoder plugin does buffer read to DMA output data from FPGA to host</li>
<li>Thus DMA to/from host is only at start and end of pipline. At other times data remain on device only and no DMA is required</li>
</ol>
<p>By way of example, the following represents the interface of the XMA Encoder
class:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>typedef struct XmaEncoderPlugin
{
    /** specific encoder type */
    XmaEncoderType  hwencoder_type;
    /** Specific encoder vendor */
    const char     *hwvendor_string;
    /** input video format fourcc index */
    XmaFormatType   format;
    /** bits per pixel for primary plane of input format */
    int32_t         bits_per_pixel;
    /** size of allocated kernel-wide private data */
    //size_t          kernel_data_size;This is removed;
    /** size of allocated private plugin data.*/
    size_t          plugin_data_size;
    /** Initalization callback.  Called during session_create() */
    int32_t         (*init)(XmaEncoderSession *enc_session);
    /** Callback called when application calls xma_enc_send_frame() */
    int32_t         (*send_frame)(XmaEncoderSession *enc_session,
                                XmaFrame          *frame);
    /** Callback called when application calls xma_enc_recv_data() */
    int32_t         (*recv_data)(XmaEncoderSession  *enc_session,
                                XmaDataBuffer      *data,
                                int32_t            *data_size);
    /** Callback called when application calls xma_enc_session_destroy() */
    int32_t         (*close)(XmaEncoderSession *session);

    /** Callback invoked at start to check compatibility with XMA version */
    int32_t         (*xma_version)(int32_t *main_version, int32_t *sub_version);

    /** Reserved */
    uint32_t        reserved[4];

} XmaEncoderPlugin;
</pre></div>
</div>
<p>Finally, the XMA offers a set of buffer management utilities that includes
the creation of frame buffers and encoded data buffers along with a set of
miscellaneous utility functions. By providing XMA buffer management
functions, it is possible for an XMA plugin to easily integrate with
virtually any higher-level media framework without requiring any
changes. Instead, it is up to the upper level media framework functions to
convert buffers into the appropriate XMA buffer.
The sections that follow will describe the layers of the API in more detail and
provide examples of how these functions are called from both the perspective of
an application and from the perspective of an XMA plugin. For the low-level
details of the APIs, please consult the doxygen documentation.</p>
</div>
<div class="section" id="sequence-of-operations">
<h2>Sequence of Operations<a class="headerlink" href="#sequence-of-operations" title="Permalink to this headline">Â¶</a></h2>
<p>In order to better understand how XMA integrates with a standard multi-media
framework such as FFmpeg, the sequence diagram that follows identifies the
critical operations and functions called as part of a hypothetical encoder. The
diagram only calls out the initialization and processing stages:</p>
<img alt="_images/XMA-Sequence-Diagram.png" class="align-center" src="_images/XMA-Sequence-Diagram.png" />
<p>As shown in the diagram above, the system is comprised of five blocks:</p>
<ul class="simple">
<li>The FFmpeg Command Line application that is used to create a processing graph</li>
<li>The FFmpeg encoder plugin that interfaces with the XMA Upper Edge Interface to manage a video session</li>
<li>The XMA Upper Edge library interface responsible for initialization, resource allocation, and dispatching of the XMA plugin</li>
<li>The XMA Lower Edge plugin responsible for interfacing with the SDAccel Video Kernel</li>
<li>The XMA Video Kernel responsible for accelerating the encoding function</li>
</ul>
<p>While this sequence diagram only shows five components, more complex systems
can be developed that include multiple accelerators with the associated XMA
plugin and FFmpeg plugin. In fact, adding new processing blocks is controlled
entirely by the FFmpeg command line and the presence of the requested
accelerator kernels. No additional development is required if all of the
SDAccel kernels are available along with the associated plugins.  In this
example, an FFmpeg command is invoked that ingests an MP4 file encoded as H.264
and re-encodes the file as H.264 at a lower bit rate. As a result, the main()
function of the FFmpeg command is invoked and this calls the xma_initialize()
function. The xma_initialize() function is called prior to executing any other
XMA functions and performs a number of initialization steps that are detailed
in a subsequent section.</p>
<p>Once the xma_initialize() successfully completes, the FFmpeg main() function
performs initialization of all requested processing plugins. In this case, the
hypothetical encoder plugin has been registered with FFmpeg and the
initialization callback of the plugin is invoked. The FFmpeg encoder plugin
begins by creating an XMA session using the xma_enc_session_create() function.
The xma_enc_session_create() function uses available resource based on the
properties supplied and, invokes the XMA
plugin initialization function. The XMA plugin initialization function
allocates any required input and output buffers on the device and performs
initialization of the SDAccel kernel if needed.
Default session ddr_bank can be provided in properties supplied to xma_enc_session_create() function. If this ddr_bank_index is -1 then XMA will automatically select default sesion ddr_bank to be used else user provided dr_bank is selected as default session ddr_bank.
Plugins may use ddr_bank other than default session ddr_bank. For using ddr bank other than default session ddr_bank use APIs xma_plg_buffer_alloc_arg_num().
Also cu_name or cu_index can be provided in properties supplied to xma_enc_session_create() function. If cu_index is -1 then cu_name is used to use CU for the session.</p>
<p>After initialization has completed, the FFmpeg main() function reads encoded
data from the specified file, decodes the data in software, and sends the raw
video frame to the FFmpeg plugin for encoding by calling the encode2() plugin
callback. The encode2() callback function converts the AVFrame into an XmaFrame
and forwards the request to the XMA Upper Edge interface via the
xma_enc_session_send_frame() function. The xma_enc_session_send_frame()
function locates the corresponding XMA plugin and invokes the send frame
callback function of the plugin. The XMA send frame callback function writes
the frame buffer data to a pre-allocated DDR buffer on the device and launches
the kernel. After the FFmpeg plugin encode2() function has sent the frame for
encoding, the next step is to determine if encoded data can be received or if
another raw frame should be sent. In most cases, an encoder will want several
raw frames before providing encoded data. Supplying multiple frames before
generated encoded data improves video quality through a look ahead and improves
performance by allowing new frame data to be written to the device DDR in
parallel with processing previously supplied frames.  Assuming a frame is ready
to be received, the xma_enc_session_recv_data() function is called by the
FFmpeg plugin and in turn results in the receive data function of the XMA
plugin being invoked. The XMA plugin communicates with the kernel to ensure
that data is ready to be received, determines the length of the encoded data,
and reads the encoded data from DDR device memory to host memory.
The description above is meant as a high-level introduction to FFmpeg and XMA.
The remainder of this document covers these topics in more depth and provides
code examples to help illustrate usage of the XMA.</p>
</div>
<div class="section" id="execution-model">
<h2>Execution model<a class="headerlink" href="#execution-model" title="Permalink to this headline">Â¶</a></h2>
<p>The APIs are:</p>
<ol class="arabic simple">
<li>xma_plg_schedule_cu_cmd</li>
<li>xma_plg_schedule_work_item</li>
<li>xma_plg_is_work_item_done</li>
<li>xma_plg_cu_cmd_status</li>
</ol>
<p>Lets consider the various purposes where the above APIs would be useful.</p>
<p><strong>xma_plg_schedule_cu_cmd / xma_plg_schedule_work_item</strong>
should be used to start the kernel with supplied kernel arguments</p>
<p><strong>xma_plg_is_work_item_done</strong> should be used to check if kernel has completed atleast one work item (previously submitted by xma_plg_schedule_cu_cmd / xma_plg_schedule_work_item).</p>
<p><strong>xma_plg_cu_cmd_status</strong> should be used to check status of kernel commands supplied as list of commands in argument (previously submitted by xma_plg_schedule_cu_cmd / xma_plg_schedule_work_item).</p>
</div>
<div class="section" id="application-development-guide">
<h2>Application Development Guide<a class="headerlink" href="#application-development-guide" title="Permalink to this headline">Â¶</a></h2>
<p>The XMA application interface is used to provide an API that can
be used to control video accelerators.  The XMA API operations
fall into four categories:</p>
<ol class="arabic simple">
<li>Initialization</li>
<li>Create session</li>
<li>Runtime frame/data processing</li>
<li>Cleanup</li>
</ol>
<div class="section" id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="Permalink to this headline">Â¶</a></h3>
<p>The first act an application must perform is that of initialization of the
system environment.  This is accomplished by calling xma_initialize() and
passing in device and xclbin info.</p>
</div>
<div class="section" id="create-session">
<h3>Create Session<a class="headerlink" href="#create-session" title="Permalink to this headline">Â¶</a></h3>
<p>Each kernel class (i.e. encoder, filter, decoder, scaler, filter, kernel)
requires different properties to be specified before a session can be created.</p>
<p>See the document for the corresponding module for more details for a given
kernel type:</p>
<ol class="arabic simple">
<li>xmadec</li>
<li>xmaenc</li>
<li>xmafilter</li>
<li>xmascaler</li>
<li>xmakernel</li>
</ol>
<p>The general initialization sequence that is common to all kernel classes is as follows:</p>
<ol class="arabic simple">
<li>define key type-specific properties of the kernel to be initialized</li>
<li>call the_session_create() routine corresponding to the kernel (e.g. xma_enc_session_create())</li>
</ol>
</div>
<div class="section" id="runtime-frame-and-data-processing">
<h3>Runtime Frame and Data Processing<a class="headerlink" href="#runtime-frame-and-data-processing" title="Permalink to this headline">Â¶</a></h3>
<p>Most kernel types include routines to consume data and then produce data from
host memory buffers.  Depending on the nature of the kernel, you may be
required to send a frame and then receive data or vice versa.
XMA defines buffer data structures that correspond to frames (XmaFrame)
or data (XmaFrameData). These buffer structures are used to communicate
with the kernel application APIs and include addresses to host memory.  The XMA Application Interface includes
functions to allocate data from host or device memory and create these containers for
you.  See xmabuffers.h for additional information.</p>
<p>Some routines, such as that of the encoder, may require multiple frames of
data before recv_data() can be called.  You must consult the API to ensure
you check for the correct return code to know how to proceed.  In the case of
the encoder, calling xma_enc_session_send_frame() may return XMA_SEND_MORE_DATA
which is an indication that calling recv_data() will not yield any data as
more frames must be sent before any output data can be received.</p>
<p>Of special note is the XmaKernel plugin type.  This kernel type is a generic
type and not necessarily video-specific. It is used to represent kernels that
perform control functions and/or other functions not easily represented by
any of the other kernel classes.</p>
</div>
<div class="section" id="cleanup">
<h3>Cleanup<a class="headerlink" href="#cleanup" title="Permalink to this headline">Â¶</a></h3>
<p>When runtime video processing has concluded, the application should destroy
each session.  Doing so will free the session to be used by another thread or
process and ensure that the kernel plugin has the opportunity to perform
proper cleanup/closing procedures.</p>
<ol class="arabic simple">
<li>xma_enc_session_destroy()</li>
<li>xma_dec_session_destroy()</li>
<li>xma_scaler_session_destroy()</li>
<li>xma_filter_session_destroy()</li>
<li>xma_kernel_session_destroy()</li>
</ol>
<p>See XMA copy_encoder &amp; copy_filter examples for more info.</p>
</div>
</div>
<div class="section" id="plugin-development-guide">
<h2>Plugin Development Guide<a class="headerlink" href="#plugin-development-guide" title="Permalink to this headline">Â¶</a></h2>
<p>The XMA Plugin Interface is used to write software capable of managing a
specific video kernel hardware resource.  The plugin interface consists of a
library for moving data between device memory and host memory and accessing
hardware registers.  Additionally, standard interfaces are defined to
represent various video kernel archtypes such as encoders, decoders, and
filters.</p>
<p>The plugin developer, by implementing a given plugin interface, permits XMA
to translate requests from XMA applications into hardware-specific actions
(i.e. register programming, buffer processing). The XMA plugin is akin to a
software âdriverâ in this regard.</p>
<p>The first step in developing an XMA plugin requires you to decide which XMA
kernel interface accurately represents the type of hardware kernel for which
you seek to provide support:</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kernel Type</th>
<th class="head">XMA Plugin Interface</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Encoders (VP9, H.264, H.265)</td>
<td>xmaplgenc</td>
</tr>
<tr class="row-odd"><td>Decoders (VP9, H.264, H.265)</td>
<td>xmaplgdec</td>
</tr>
<tr class="row-even"><td>Filters (colorspace converter, scalers)</td>
<td>xmaplgfilter or xmaplgscaler</td>
</tr>
<tr class="row-odd"><td>Scalers</td>
<td>xmaplgscaler</td>
</tr>
<tr class="row-even"><td>Other (embedded cpu)</td>
<td>xmaplgkernel</td>
</tr>
</tbody>
</table>
<p>Once selected, the job of the plugin author is to implement the interface
for the given kernel thus providing a mapping between the xma_app_intf and
the kernel.  Most callbacks specified are implicitly mandatory with some exceptions
which will be noted below.</p>
<p>Your plugin will be compiled into a shared object library and linked to the
kernel via create_session properties:</p>
<p>All plugin code must include xmaplugin.h</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#include &lt;xmaplugin.h&gt;
</pre></div>
</div>
<p>This will provide the plugin code access to all data structures necessary
to author XMA plugin code.  This includes access to the structures used
by the xma_app_intf as xmaplugin.h includes xma.h.</p>
<p>What follows is a general description of what is expected of a plugin in
response to the xma_app_intf.</p>
<p>From the application perspective, the following operations
will be peformed:</p>
<ol class="arabic simple">
<li>Create session</li>
<li>Send data/frame or write**</li>
<li>Receive data/frame or read**</li>
<li>Destroy</li>
</ol>
<p>** in the case of a non-video kernel</p>
<p>Steps 2 and 3 will form the runtime processing of frames/data and likely
repeated for as long as there is data to be processed.</p>
<p>A general mapping between the application interface and plugin interface:</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Application Call</th>
<th class="head">Plugin Callbacks Invoked</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>session_create()</td>
<td>init()</td>
</tr>
<tr class="row-odd"><td>send_(data|frame)()</td>
<td>send_(data|frame)()</td>
</tr>
<tr class="row-even"><td>recv_(data|frame)()</td>
<td>recv_(data|frame)()</td>
</tr>
<tr class="row-odd"><td>destroy()</td>
<td>close()</td>
</tr>
</tbody>
</table>
<div class="section" id="initalization">
<h3>Initalization<a class="headerlink" href="#initalization" title="Permalink to this headline">Â¶</a></h3>
<p>Initialization is the time for a plugin to perform one or more of the
following:</p>
<ol class="arabic simple">
<li>allocate device buffers to handle input data as well as output data</li>
<li>initalize the state of the kernel</li>
</ol>
<p>When a session has been created in response to an application request,
XMA will allocate plugin data that
is session-specific.</p>
<p>XmaSession-&gt;plugin_data member is
available to plugin to store the necessary session-specific
state as necessary. There is no need to free these data structures during
termination; XMA frees this data for you.</p>
<p>To allocate buffers necessary to handle both incoming and outgoing
data, please see</p>
<ol class="arabic simple">
<li>xma_plg_buffer_alloc(): Allocate device buffer on default session ddr_bank</li>
<li>xma_plg_buffer_alloc_arg_num(): Allocate device buffer on ddr_bank connected to a kernel argument</li>
</ol>
</div>
<div class="section" id="handling-incoming-application-data">
<h3>Handling Incoming Application Data<a class="headerlink" href="#handling-incoming-application-data" title="Permalink to this headline">Â¶</a></h3>
<p>For each kernel type, there is an application interface to send data to be
proceessed (i.e. encoded, decoded, or otherwised transformed).
Data being sent by an application to the kernel will result in the invocation
of your send()/write() callback.</p>
<p>The most common operation within the plugin is to copy data from host
memory to device memory so that it may be operated on by the kernel.
Subsequently, the kernel must be programmed to know which device buffer
contains the data to be processed and programmed appropriately.</p>
<p>The XMA Plugin library call xma_plg_buffer_write() can be used to copy
host data to device data.</p>
<p>xma_plg_schedule_cu_cmd() or xma_plg_schedule_work_item() can be used to program
the kernel registers and start kernel processing.</p>
</div>
<div class="section" id="sending-output-to-the-application">
<h3>Sending Output to the Application<a class="headerlink" href="#sending-output-to-the-application" title="Permalink to this headline">Â¶</a></h3>
<p>For each kernel type, there is an application interface to request processed
data (i.e. encoded, decoded, otherwise transformed) by the kernel.  Data
being requested by an application from the kernel will invoke your
recv()/read() callback implementation.</p>
<p>The most common operation within the plugin is to copy data from device
memory back to host memory so that it may be processed by the application.
Subsequently, the kernel may be prepared for new data to arrive for processing.</p>
<p>The XMA Plugin library call xma_plg_buffer_read() can be used to copy
host data to device data.</p>
</div>
<div class="section" id="termination">
<h3>Termination<a class="headerlink" href="#termination" title="Permalink to this headline">Â¶</a></h3>
<p>When an XMA application has concluded data processing, it will destroy its
kernel session.  Your close() callback will be invoked to perform the necessary
cleanup.  Your close() implementation should free any buffers that were
allocated in device memory during your init() via xma_plg_buffer_free().
Freeing XmaSession-&gt;plugin_data is not necessary
as this will be done by the XMA library.</p>
</div>
<div class="section" id="zerocopy-special-case">
<h3>Zerocopy Special Case<a class="headerlink" href="#zerocopy-special-case" title="Permalink to this headline">Â¶</a></h3>
<p>Encoders are capable of receiving data directly from upstream video processing
kernels such as filters or scalers.  In such a case, it may improve the
the performance of a video processing pipeline that includes both a filter and
an encoder to exchange data directly within device memory rather than have
the filter copy data back to a host buffer only to be re-copied from the host
to the device buffer of the downstream encoder.  This double-copy can be
avoided if the two kernels can share a buffer within the device memory; a
buffer that serves as an âoutputâ buffer for the filter but an âinputâ
buffer for the encoder. This optimization is known as âzerocopyâ.</p>
<p>Use XRM for system resource reservation such that zero-copy is possible
XmaFrame with device only buffer can be output of plugins supporting zero-copy and feeding zero-copy enabled plugin/s
Plugins may use dev_index, bank_index &amp; device_only info from BufferObject to enable or disable zero-copy</p>
<p>See XMA copy_encoder &amp; copy_filter examples for more info.</p>
<p>For stateful/multi-channel kernels (eg decodre, encoder):</p>
<ol class="arabic simple">
<li>Use dataflow kernels with context/channels for best performance. Use HLS/RTL Wizard with appropriate settings to generate these kernels in 2019.2 release toolset.</li>
<li>All work items within a channel are treated as FIFO. Kernel must maintain this order for a channel.</li>
<li>See spec for kernels with dataflow with channels. Kernel regamp registers at offset 0x10 (channel_id input to kernel) and 0x14 (channel_id output from kernel) must be supported by kernels.</li>
<li>Use xrt_ini settings (dataflow; kernel_channels) to enable dataflow kernel with channels</li>
</ol>
<p>QDMA Platform:</p>
<ol class="arabic simple">
<li>Host to kernel streams will be supported by XMA in future</li>
<li>Pre defined commands packets maybe used to implement streaming kenels with standard command interface</li>
<li>Pre define command format will be provided</li>
</ol>
<p>Using DRM (Digital Right Management) IPs:</p>
<ol class="arabic simple">
<li>For register read/write use XRT APIs from libxrt_core</li>
<li>Use APIs xclRead &amp; xclWrite. APIs are depricated and will be removed in 2020.2 release</li>
<li>xclRegRead/Write APIs may NOT work for DRM IPs depending on application setup/use-case</li>
<li>Register read/write is discouraged</li>
<li>DRM solution/setup without register read/write is preferred</li>
<li>DRM solution/setup using standard XMA APis is preferred</li>
<li>DRM IP as independent kernel should meet above suggestions</li>
</ol>
<p>Compiling ffmpeg or host aplication with libxma2api:</p>
<ol class="arabic simple">
<li>GCC link flag to use: -Wl,âunresolved-symbols=ignore-in-shared-libs</li>
<li>Example ffmpeg configure cmd:</li>
</ol>
<p>./configure âprefix=/root_path/ffmpeg/build âpkg-config-flags=ââstaticâ âextra-cflags=â-I/opt/xilinx/xrt/include/xma2 -I/root_path/ffmpeg/build/includeâ âextra-ldflags=â-L/opt/xilinx/xrt/lib -L/root_path/ffmpeg/build/libâ âextra-libs=â-Wl,âunresolved-symbols=ignore-in-shared-libs -lxma2api -lpthread -ldlâ âbindir=/root_path/ffmpeg/bin âenable-pthreads âenable-shared âenable-libxma2api âenable-pic âenable-gpl âenable-nonfree</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="xma_19.2.html" class="btn btn-neutral float-right" title="XMA 19.2 Migration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="xrt_ini.html" class="btn btn-neutral float-left" title="Configuration File xrt.ini" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2020, Xilinx, Inc

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>