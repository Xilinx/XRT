<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XRT: xrt::run Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XRT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexrt.html">xrt</a></li><li class="navelem"><a class="el" href="classxrt_1_1run.html">run</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classxrt_1_1run-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xrt::run Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classxrt_1_1run.html" title="xrt::run represents one execution of a kernel">xrt::run</a> represents one execution of a kernel  
 <a href="classxrt_1_1run.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="xrt__kernel_8h_source.html">xrt_kernel.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43f61719426fff8f5f24f0d550e0f29f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a43f61719426fff8f5f24f0d550e0f29f">run</a> ()=default</td></tr>
<tr class="separator:a43f61719426fff8f5f24f0d550e0f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519b58fe315478c16889ceab6597a76a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a519b58fe315478c16889ceab6597a76a">run</a> (const <a class="el" href="classxrt_1_1kernel.html">kernel</a> &amp;krnl)</td></tr>
<tr class="separator:a519b58fe315478c16889ceab6597a76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada025d6709796a6ea20182e5b720a96b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#ada025d6709796a6ea20182e5b720a96b">start</a> ()</td></tr>
<tr class="separator:ada025d6709796a6ea20182e5b720a96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d538a36fb17a6b7dc58e9c9fd4cda6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#af4d538a36fb17a6b7dc58e9c9fd4cda6">start</a> (const <a class="el" href="structxrt_1_1autostart.html">autostart</a> &amp;iterations)</td></tr>
<tr class="separator:af4d538a36fb17a6b7dc58e9c9fd4cda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae133bb9766ad5daac80bbad0bc748720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#ae133bb9766ad5daac80bbad0bc748720">stop</a> ()</td></tr>
<tr class="separator:ae133bb9766ad5daac80bbad0bc748720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4697b4f95bbb0d67711772ced21b1cd"><td class="memItemLeft" align="right" valign="top">ert_cmd_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#ac4697b4f95bbb0d67711772ced21b1cd">abort</a> ()</td></tr>
<tr class="separator:ac4697b4f95bbb0d67711772ced21b1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf1ff8225e15d8802401982f62321e5"><td class="memItemLeft" align="right" valign="top">ert_cmd_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#afaf1ff8225e15d8802401982f62321e5">wait</a> (const std::chrono::milliseconds &amp;timeout=std::chrono::milliseconds{0}) const</td></tr>
<tr class="separator:afaf1ff8225e15d8802401982f62321e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788df7565091221de5376d6c1d4a5f24"><td class="memItemLeft" align="right" valign="top">ert_cmd_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a788df7565091221de5376d6c1d4a5f24">wait</a> (unsigned int timeout_ms) const</td></tr>
<tr class="separator:a788df7565091221de5376d6c1d4a5f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baec6b476f99e4e10a06044690558ac"><td class="memItemLeft" align="right" valign="top">ert_cmd_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a3baec6b476f99e4e10a06044690558ac">state</a> () const</td></tr>
<tr class="separator:a3baec6b476f99e4e10a06044690558ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268c7ad2d9bab32d6ba2878a0b00c628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a268c7ad2d9bab32d6ba2878a0b00c628">add_callback</a> (ert_cmd_state <a class="el" href="classxrt_1_1run.html#a3baec6b476f99e4e10a06044690558ac">state</a>, std::function&lt; void(const void *, ert_cmd_state, void *)&gt; callback, void *data)</td></tr>
<tr class="separator:a268c7ad2d9bab32d6ba2878a0b00c628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa768dd562f3d84242644134c79c83e46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#aa768dd562f3d84242644134c79c83e46">operator bool</a> () const</td></tr>
<tr class="separator:aa768dd562f3d84242644134c79c83e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17b3aebcbcfc41859e109515fae3557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#af17b3aebcbcfc41859e109515fae3557">operator&lt;</a> (const <a class="el" href="classxrt_1_1run.html">xrt::run</a> &amp;rhs) const</td></tr>
<tr class="separator:af17b3aebcbcfc41859e109515fae3557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a86a2d453010753756d590e2032e21a"><td class="memTemplParams" colspan="2">template&lt;typename ArgType &gt; </td></tr>
<tr class="memitem:a8a86a2d453010753756d590e2032e21a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a8a86a2d453010753756d590e2032e21a">set_arg</a> (int index, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a8a86a2d453010753756d590e2032e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f4e82835cdf8f601f2ef24e3067390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#ac5f4e82835cdf8f601f2ef24e3067390">set_arg</a> (int index, <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;boh)</td></tr>
<tr class="separator:ac5f4e82835cdf8f601f2ef24e3067390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6452285402383d151df1fb1bc9f44227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a6452285402383d151df1fb1bc9f44227">set_arg</a> (int index, const <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;boh)</td></tr>
<tr class="separator:a6452285402383d151df1fb1bc9f44227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00352eeb61b2c185e23c32840dfc61ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a00352eeb61b2c185e23c32840dfc61ea">set_arg</a> (int index, <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;&amp;boh)</td></tr>
<tr class="separator:a00352eeb61b2c185e23c32840dfc61ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ee8f980ab4730a247015501feee605"><td class="memTemplParams" colspan="2">template&lt;typename ArgType &gt; </td></tr>
<tr class="memitem:a53ee8f980ab4730a247015501feee605"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a53ee8f980ab4730a247015501feee605">update_arg</a> (int index, ArgType &amp;&amp;arg)</td></tr>
<tr class="separator:a53ee8f980ab4730a247015501feee605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fa11c122834664d7d24c7c2867c834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a15fa11c122834664d7d24c7c2867c834">update_arg</a> (int index, const <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;boh)</td></tr>
<tr class="separator:a15fa11c122834664d7d24c7c2867c834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b075fdd181319c5edbdd4e04db109f"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a66b075fdd181319c5edbdd4e04db109f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a66b075fdd181319c5edbdd4e04db109f">operator()</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a66b075fdd181319c5edbdd4e04db109f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516813415547dd39c27d0219277f2513"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; </td></tr>
<tr class="memitem:a516813415547dd39c27d0219277f2513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classxrt_1_1run.html#a516813415547dd39c27d0219277f2513">operator()</a> (<a class="el" href="structxrt_1_1autostart.html">autostart</a> &amp;&amp;count, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a516813415547dd39c27d0219277f2513"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classxrt_1_1run.html" title="xrt::run represents one execution of a kernel">xrt::run</a> represents one execution of a kernel </p>
<p>The run handle can be explicitly constructed from a kernel object or implicitly constructed from starting a kernel execution.</p>
<p>A run handle can be re-used to execute the same kernel again. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43f61719426fff8f5f24f0d550e0f29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f61719426fff8f5f24f0d550e0f29f">&#9670;&nbsp;</a></span>run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xrt::run::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#a43f61719426fff8f5f24f0d550e0f29f">run()</a> - Construct empty run object</p>
<p>Can be used as lvalue in assignment. </p>

</div>
</div>
<a id="a519b58fe315478c16889ceab6597a76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519b58fe315478c16889ceab6597a76a">&#9670;&nbsp;</a></span>run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xrt::run::run </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxrt_1_1kernel.html">kernel</a> &amp;&#160;</td>
          <td class="paramname"><em>krnl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#a43f61719426fff8f5f24f0d550e0f29f">run()</a> - Construct run object from a kernel object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">krnl</td><td>Kernel object representing the kernel to execute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4697b4f95bbb0d67711772ced21b1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4697b4f95bbb0d67711772ced21b1cd">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ert_cmd_state xrt::run::abort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#ac4697b4f95bbb0d67711772ced21b1cd">abort()</a> - Abort a run object that has been started</p>
<dl class="section return"><dt>Returns</dt><dd>State of aborted command</dd></dl>
<p>If the run object has been sent to scheduler for execution, then this function can be used to abort the scheduled command.</p>
<p>The function is synchronous and will wait for abort to complete. The return value is the state of the aborted command. </p>

</div>
</div>
<a id="a268c7ad2d9bab32d6ba2878a0b00c628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268c7ad2d9bab32d6ba2878a0b00c628">&#9670;&nbsp;</a></span>add_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::add_callback </td>
          <td>(</td>
          <td class="paramtype">ert_cmd_state&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const void *, ert_cmd_state, void *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#a268c7ad2d9bab32d6ba2878a0b00c628">add_callback()</a> - Add a callback function for run state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>State to invoke callback on </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function </td></tr>
    <tr><td class="paramname">data</td><td>User data to pass to callback function</td></tr>
  </table>
  </dd>
</dl>
<p>The function is called when the run object changes state to argument state or any error state. Only <code>ERT_CMD_STATE_COMPLETED</code> is supported currently.</p>
<p>The function object's first parameter is a unique 'key' for this <a class="el" href="classxrt_1_1run.html" title="xrt::run represents one execution of a kernel">xrt::run</a> object implmentation on which the callback was added. This 'key' can be used to identify an actual run object that refers to the implementaion that is maybe shared by multiple <a class="el" href="classxrt_1_1run.html" title="xrt::run represents one execution of a kernel">xrt::run</a> objects.</p>
<p>Any number of callbacks are supported. </p>

</div>
</div>
<a id="aa768dd562f3d84242644134c79c83e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa768dd562f3d84242644134c79c83e46">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xrt::run::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator bool() - Check if run handle is valid</p>
<dl class="section return"><dt>Returns</dt><dd>True if run is associated with kernel object, false otherwise </dd></dl>

</div>
</div>
<a id="a66b075fdd181319c5edbdd4e04db109f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b075fdd181319c5edbdd4e04db109f">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::operator() </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator() - Set all kernel arguments and start the run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Kernel arguments</td></tr>
  </table>
  </dd>
</dl>
<p>Use this API to explicitly set all kernel arguments and start kernel execution. </p>

</div>
</div>
<a id="a516813415547dd39c27d0219277f2513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516813415547dd39c27d0219277f2513">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxrt_1_1autostart.html">autostart</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator() - Set all kernel arguments and start the run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>Iteration count specifying number of iterations of the run </td></tr>
    <tr><td class="paramname">args</td><td>Kernel arguments</td></tr>
  </table>
  </dd>
</dl>
<p>Use this API to explicitly set all kernel arguments and start kernel execution for specified number of iterations.</p>
<p>An iteration count of '1' invokes the kernel once and is the same as calling the operator without specifying <code>autostart</code>.</p>
<p>The run is complete only after all iterations have completed or when the kernel has been explicitly stopped using <code><a class="el" href="classxrt_1_1run.html#ae133bb9766ad5daac80bbad0bc748720">stop()</a></code>.</p>
<p>Currently autostart is only supported for kernels with one compute unit which must be opened in exclusive mode. </p>

</div>
</div>
<a id="af17b3aebcbcfc41859e109515fae3557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17b3aebcbcfc41859e109515fae3557">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool xrt::run::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxrt_1_1run.html">xrt::run</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator &lt; () - Weak ordering</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>Object to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if object is ordered less that compared with other </dd></dl>

</div>
</div>
<a id="a8a86a2d453010753756d590e2032e21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a86a2d453010753756d590e2032e21a">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#a8a86a2d453010753756d590e2032e21a">set_arg()</a> - Set a specific kernel scalar argument for this run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of kernel argument to update </td></tr>
    <tr><td class="paramname">arg</td><td><br  />
 The scalar argument value to set.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this API to explicit set or change a kernel argument prior to starting kernel execution. After setting arguments, the kernel can be started using <code><a class="el" href="classxrt_1_1run.html#ada025d6709796a6ea20182e5b720a96b">start()</a></code> on the run object.</p>
<p>See also <code>operator()</code> to set all arguments and start kernel. </p>

</div>
</div>
<a id="a6452285402383d151df1fb1bc9f44227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6452285402383d151df1fb1bc9f44227">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;&#160;</td>
          <td class="paramname"><em>boh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>set_arg - <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> variant for const lvalue </p>

</div>
</div>
<a id="a00352eeb61b2c185e23c32840dfc61ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00352eeb61b2c185e23c32840dfc61ea">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>boh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>set_arg - <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> variant for rvalue </p>

</div>
</div>
<a id="ac5f4e82835cdf8f601f2ef24e3067390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f4e82835cdf8f601f2ef24e3067390">&#9670;&nbsp;</a></span>set_arg() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::set_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;&#160;</td>
          <td class="paramname"><em>boh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#a8a86a2d453010753756d590e2032e21a">set_arg()</a> - Set a specific kernel global argument for a run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of kernel argument to set </td></tr>
    <tr><td class="paramname">boh</td><td>The global buffer argument value to set (lvalue).</td></tr>
  </table>
  </dd>
</dl>
<p>Use this API to explicit set or change a kernel argument prior to starting kernel execution. After setting arguments, the kernel can be started using <code><a class="el" href="classxrt_1_1run.html#ada025d6709796a6ea20182e5b720a96b">start()</a></code> on the run object.</p>
<p>See also <code>operator()</code> to set all arguments and start kernel. </p>

</div>
</div>
<a id="ada025d6709796a6ea20182e5b720a96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada025d6709796a6ea20182e5b720a96b">&#9670;&nbsp;</a></span>start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#ada025d6709796a6ea20182e5b720a96b">start()</a> - Start one execution of a run.</p>
<p>This function is asynchronous, run status must be expclicit checked or <code><a class="el" href="classxrt_1_1run.html#afaf1ff8225e15d8802401982f62321e5">wait()</a></code> must be used to wait for the run to complete. </p>

</div>
</div>
<a id="af4d538a36fb17a6b7dc58e9c9fd4cda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d538a36fb17a6b7dc58e9c9fd4cda6">&#9670;&nbsp;</a></span>start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxrt_1_1autostart.html">autostart</a> &amp;&#160;</td>
          <td class="paramname"><em>iterations</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#ada025d6709796a6ea20182e5b720a96b">start()</a> - Start auto-restart execution of a run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterations</td><td><br  />
 Number of times to iterate the same run. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<p>An iteration count of zero means that the kernel should run forever, or until explicitly stopped using <code><a class="el" href="classxrt_1_1run.html#ae133bb9766ad5daac80bbad0bc748720">stop()</a></code>.</p>
<p>This function is asynchronous, run status must be expclicit checked or <code><a class="el" href="classxrt_1_1run.html#afaf1ff8225e15d8802401982f62321e5">wait()</a></code> must be used to wait for the run to complete.</p>
<p>The kernel run object is complete only after all iterations have completed, or until run object has been explicitly stopped.</p>
<p>Changing kernel arguments <code><a class="el" href="classxrt_1_1run.html#a8a86a2d453010753756d590e2032e21a">set_arg()</a></code> while the kernel is running has undefined behavior. To synchronize change of arguments, please use xrt::mailbox.</p>
<p>Currently autostart is only supported for kernels with one compute unit which must be opened in exclusive mode. </p>

</div>
</div>
<a id="a3baec6b476f99e4e10a06044690558ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3baec6b476f99e4e10a06044690558ac">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ert_cmd_state xrt::run::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#a3baec6b476f99e4e10a06044690558ac">state()</a> - Check the current state of a run object</p>
<dl class="section return"><dt>Returns</dt><dd>Current state of this run object</dd></dl>
<p>The state values are defined in <code>include/ert.h</code> </p>

</div>
</div>
<a id="ae133bb9766ad5daac80bbad0bc748720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae133bb9766ad5daac80bbad0bc748720">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#ae133bb9766ad5daac80bbad0bc748720">stop()</a> - Stop kernel run object at next safe iteration</p>
<p>If the kernel run object has been started by specifying an iteration count or by specifying default iteration count, then this function can be used to stop the iteration early. <br  />
</p>
<p>The function is synchronous and waits for the kernel run object to complete.</p>
<p>If the kernel is not iterating, then calling this funciton is the same as calling <code><a class="el" href="classxrt_1_1run.html#afaf1ff8225e15d8802401982f62321e5">wait()</a></code>. </p>

</div>
</div>
<a id="a53ee8f980ab4730a247015501feee605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ee8f980ab4730a247015501feee605">&#9670;&nbsp;</a></span>update_arg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::update_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgType &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>udpdate_arg() - Asynchronous update of scalar kernel global argument</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of kernel argument to update </td></tr>
    <tr><td class="paramname">arg</td><td>The scalar argument value to set.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this API to asynchronously update a specific scalar argument of the kernel associated with the run object.</p>
<p>This API is only supported on Edge. </p>

</div>
</div>
<a id="a15fa11c122834664d7d24c7c2867c834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fa11c122834664d7d24c7c2867c834">&#9670;&nbsp;</a></span>update_arg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xrt::run::update_arg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxrt_1_1bo.html">xrt::bo</a> &amp;&#160;</td>
          <td class="paramname"><em>boh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#a53ee8f980ab4730a247015501feee605">update_arg()</a> - Asynchronous update of kernel global argument for a run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of kernel argument to update </td></tr>
    <tr><td class="paramname">boh</td><td>The global buffer argument value to set.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this API to asynchronously update a specific kernel argument of an existing run. <br  />
</p>
<p>This API is only supported on Edge. </p>

</div>
</div>
<a id="afaf1ff8225e15d8802401982f62321e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf1ff8225e15d8802401982f62321e5">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ert_cmd_state xrt::run::wait </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::milliseconds &amp;&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds{0}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#afaf1ff8225e15d8802401982f62321e5">wait()</a> - Wait for a run to complete execution</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td><br  />
 Timeout for wait (default block till run completes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Command state upon return of wait, or ERT_CMD_STATE_TIMEOUT if timeout exceeded.</dd></dl>
<p>The default timeout of 0ms indicates blocking until run completes.</p>
<p>The current thread will block until the run completes or timeout expires. Completion does not guarantee success, the run status should be checked by using <code>state</code>.</p>
<p>If specified time out is exceeded, the function returns with ERT_CMD_STATE_TIMEOUT, it is the callers responsibility to abort the run if it continues to time out.</p>
<p>The current implementation of this API can mask out the timeout of this run so that the call either never returns or doesn't return until the run completes by itself. This can happen if other runs are continuosly completing within the specified timeout for this run. If the device is otherwise idle, or if the time between run completion exceeds the specified timeout, then this function will identify the timeout. </p>

</div>
</div>
<a id="a788df7565091221de5376d6c1d4a5f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788df7565091221de5376d6c1d4a5f24">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ert_cmd_state xrt::run::wait </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classxrt_1_1run.html#afaf1ff8225e15d8802401982f62321e5">wait()</a> - Wait for specified milliseconds for run to complete</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>Timeout in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Command state upon return of wait, or ERT_CMD_STATE_TIMEOUT if timeout exceeded.</dd></dl>
<p>The default timeout of 0ms indicates blocking until run completes.</p>
<p>The current thread will block until the run completes or timeout expires. Completion does not guarantee success, the run status should be checked by using <code>state</code>.</p>
<p>If specified time out is exceeded, the function returns with ERT_CMD_STATE_TIMEOUT, it is the callers responsibility to abort the run if it continues to time out.</p>
<p>The current implementation of this API can mask out the timeout of this run so that the call either never returns or doesn't return until the run completes by itself. This can happen if other runs are continuosly completing within the specified timeout for this run. If the device is otherwise idle, or if the time between run completion exceeds the specified timeout, then this function will identify the timeout. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/scratch/udayd/DOC/XRT/src/runtime_src/core/include/xrt/<a class="el" href="xrt__kernel_8h_source.html">xrt_kernel.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
