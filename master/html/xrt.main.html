

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Xilinx Runtime (XRT) Core Library &mdash; Xilinx Runtime 2019.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Embedded Runtime Library" href="ert.main.html" />
    <link rel="prev" title="Xilinx Media Accelerator (XMA) Core Library" href="xma.main.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Xilinx Runtime
          

          
          </a>

          
            
            
              <div class="version">
                2019.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">XRT Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">Platform Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building and Installing Software Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">XRT Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">XRT Use Model and Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="execution-model.html">Execution Model Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocess.html">Multi-Process Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2p.html">PCIe Peer-to-Peer Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="m2m.html">Memory-to-Memory (M2M) Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma.main.html">Xilinx Media Accelerator (XMA) Core Library</a></li>
</ul>
<p class="caption"><span class="caption-text">XRT API Library</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Xilinx Runtime (XRT) Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="ert.main.html">Embedded Runtime Library</a></li>
</ul>
<p class="caption"><span class="caption-text">Kernel Driver</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sysfs.html">Linux Sys FileSystem Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="mgmt-ioctl.main.html">XCLMGMT (PCIe Management Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="xocl_ioctl.main.html">XOCL (PCIe User Physical Function) Driver Interfaces</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools and Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Board Tools and Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats.html">Binary Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="xclbintools.html">Xclbin Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Platform Building</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="yocto.html">Yocto Recipes For Embedded Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="newdsa-bringup.html">New DSA Bringup</a></li>
<li class="toctree-l1"><a class="reference internal" href="create_platforms.html">Create MPSoC Based Embedded Platforms</a></li>
</ul>
<p class="caption"><span class="caption-text">Cloud Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mailbox.main.html">Mailbox Subdevice Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailbox.proto.html">Mailbox Inter-domain Communication Protocol</a></li>
</ul>
<p class="caption"><span class="caption-text">Debug and Faqs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="debug-faq.html">XRT/Board Debug FAQ</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Xilinx Runtime</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Xilinx Runtime (XRT) Core Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/xrt.main.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xilinx-runtime-xrt-core-library">
<span id="xrt-main-rst"></span><h1>Xilinx Runtime (XRT) Core Library<a class="headerlink" href="#xilinx-runtime-xrt-core-library" title="Permalink to this headline">¶</a></h1>
<p><strong>Xilinx Runtime (XRT) Library Interface Definitions</strong></p>
<p>Header file <em>xrt.h</em> defines data structures and function signatures exported by
Xilinx Runtime (XRT) Library. XRT is part of software stack which is integrated
into Xilinx reference platform.</p>
<dl class="type">
<dt id="c.xclDeviceHandle">
typedef <code class="descname">xclDeviceHandle</code><a class="headerlink" href="#c.xclDeviceHandle" title="Permalink to this definition">¶</a></dt>
<dd><p>opaque device handle</p>
</dd></dl>

<p><strong>Description</strong></p>
<p>A device handle of xclDeviceHandle kind is obtained by opening a device. Clients pass this
device handle to refer to the opened device in all future interaction with XRT.</p>
<p><strong>XRT Device Management APIs</strong></p>
<hr class="docutils" />
<dl class="function">
<dt id="c.xclProbe">
XCL_DRIVER_DLLESPEC unsigned <code class="descname">xclProbe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.xclProbe" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumerate devices found in the system</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<p><strong>Return</strong></p>
<p>count of devices found</p>
<dl class="function">
<dt id="c.xclOpen">
XCL_DRIVER_DLLESPEC <a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a> <code class="descname">xclOpen</code><span class="sig-paren">(</span>unsigned<em> deviceIndex</em>, const char *<em> logFileName</em>, enum xclVerbosityLevel<em> level</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclOpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a device and obtain its handle.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">deviceIndex</span></code></dt><dd><p>Slot number of device 0 for first device, 1 for the second device…</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">logFileName</span></code></dt><dd><p>Log file to use for optional logging</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xclVerbosityLevel</span> <span class="pre">level</span></code></dt><dd><p>Severity level of messages to log</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Device handle</p>
<dl class="function">
<dt id="c.xclClose">
XCL_DRIVER_DLLESPEC void <code class="descname">xclClose</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclClose" title="Permalink to this definition">¶</a></dt>
<dd><p>Close an opened device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xclResetDevice">
XCL_DRIVER_DLLESPEC int <code class="descname">xclResetDevice</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, enum xclResetKind<em> kind</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclResetDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset a device or its CL</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xclResetKind</span> <span class="pre">kind</span></code></dt><dd><p>Reset kind</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>Reset the device. All running kernels will be killed and buffers in DDR will be
purged. A device may be reset if a user’s application dies without waiting for
running kernel(s) to finish.</p>
<dl class="function">
<dt id="c.xclGetDeviceInfo2">
XCL_DRIVER_DLLESPEC int <code class="descname">xclGetDeviceInfo2</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, struct xclDeviceInfo2 *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclGetDeviceInfo2" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain various bits of information from the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xclDeviceInfo2</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>Information record</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<dl class="function">
<dt id="c.xclGetUsageInfo">
XCL_DRIVER_DLLESPEC int <code class="descname">xclGetUsageInfo</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, struct xclDeviceUsage *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclGetUsageInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain usage information from the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xclDeviceUsage</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>Information record</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<dl class="function">
<dt id="c.xclGetErrorStatus">
XCL_DRIVER_DLLESPEC int <code class="descname">xclGetErrorStatus</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, struct xclErrorStatus *<em> info</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclGetErrorStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain error information from the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xclErrorStatus</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>Information record</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<dl class="function">
<dt id="c.xclLoadXclBin">
XCL_DRIVER_DLLESPEC int <code class="descname">xclLoadXclBin</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, const struct axlf *<em> buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclLoadXclBin" title="Permalink to this definition">¶</a></dt>
<dd><p>Download FPGA image (xclbin) to the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">struct</span> <span class="pre">axlf</span> <span class="pre">*</span> <span class="pre">buffer</span></code></dt><dd><p>Pointer to device image (xclbin) in memory</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>Download FPGA image (AXLF) to the device. The PR bitstream is encapsulated inside
xclbin as a section. xclbin may also contains other sections which are suitably
handled by the driver.</p>
<dl class="function">
<dt id="c.xclGetSectionInfo">
XCL_DRIVER_DLLESPEC int <code class="descname">xclGetSectionInfo</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, void *<em> info</em>, size_t *<em> size</em>, enum axlf_section_kind<em> kind</em>, int<em> index</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclGetSectionInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Information from sysfs about the downloaded xclbin sections</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">info</span></code></dt><dd><p>Pointer to preallocated memory which will store the return value.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">*</span> <span class="pre">size</span></code></dt><dd><p>Pointer to preallocated memory which will store the return size.
kind:           axlf_section_kind for which info is being queried
index:          The (sub)section index for the “kind” type.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">axlf_section_kind</span> <span class="pre">kind</span></code></dt><dd><p><em>undescribed</em></p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">index</span></code></dt><dd><p><em>undescribed</em></p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>Get the section information from sysfs. The index corrresponds to the (section) entry
of the axlf_section_kind data being queried. The info and the size contain the return
binary value of the subsection and its size.</p>
<dl class="function">
<dt id="c.xclReClock2">
XCL_DRIVER_DLLESPEC int <code class="descname">xclReClock2</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned short<em> region</em>, const unsigned short *<em> targetFreqMHz</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclReClock2" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure PR region frequncies</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">region</span></code></dt><dd><p>PR region (always 0)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unsigned</span> <span class="pre">short</span> <span class="pre">*</span> <span class="pre">targetFreqMHz</span></code></dt><dd><p>Array of target frequencies in order for the Clock Wizards driving
the PR region</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<dl class="function">
<dt id="c.xclLockDevice">
XCL_DRIVER_DLLESPEC int <code class="descname">xclLockDevice</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclLockDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>Get exclusive ownership of the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>The lock is necessary before performing buffer migration, register access or
bitstream downloads.</p>
<dl class="function">
<dt id="c.xclUnlockDevice">
XCL_DRIVER_DLLESPEC int <code class="descname">xclUnlockDevice</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclUnlockDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>Release exclusive ownership of the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<dl class="function">
<dt id="c.xclOpenContext">
XCL_DRIVER_DLLESPEC int <code class="descname">xclOpenContext</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, uuid_t<em> xclbinId</em>, unsigned int<em> ipIndex</em>, bool<em> shared</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclOpenContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Create shared/exclusive context on compute units</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid_t</span> <span class="pre">xclbinId</span></code></dt><dd><p>UUID of the xclbin image running on the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">ipIndex</span></code></dt><dd><p>IP/CU index in the IP LAYOUT array</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">shared</span></code></dt><dd><p>Shared access or exclusive access</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>The context is necessary before submitting execution jobs using <a class="reference internal" href="#c.xclExecBuf" title="xclExecBuf"><code class="xref c c-func docutils literal notranslate"><span class="pre">xclExecBuf()</span></code></a>. Contexts may be
exclusive or shared. Allocation of exclusive contexts on a compute unit would succeed
only if another client has not already setup up a context on that compute unit. Shared
contexts can be concurrently allocated by many processes on the same compute units.</p>
<dl class="function">
<dt id="c.xclCloseContext">
XCL_DRIVER_DLLESPEC int <code class="descname">xclCloseContext</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, uuid_t<em> xclbinId</em>, unsigned<em> ipIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclCloseContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Close previously opened context</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uuid_t</span> <span class="pre">xclbinId</span></code></dt><dd><p>UUID of the xclbin image running on the device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">ipIndex</span></code></dt><dd><p>IP/CU index in the IP LAYOUT array</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>Close a previously allocated shared/exclusive context for a compute unit.</p>
<dl class="function">
<dt id="c.xclBootFPGA">
XCL_DRIVER_DLLESPEC int <code class="descname">xclBootFPGA</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclBootFPGA" title="Permalink to this definition">¶</a></dt>
<dd><p>Boot the FPGA from PROM</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>This should only be called when there are no other clients. It will cause PCIe bus re-enumeration</p>
<dl class="function">
<dt id="c.xclLogMsg">
XCL_DRIVER_DLLESPEC int <code class="descname">xclLogMsg</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, enum xrtLogMsgLevel<em> level</em>, const char *<em> tag</em>, const char *<em> format</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#c.xclLogMsg" title="Permalink to this definition">¶</a></dt>
<dd><p>Send message to log file as per settings in ini file.</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xrtLogMsgLevel</span> <span class="pre">level</span></code></dt><dd><p>Severity level of the msg</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">tag</span></code></dt><dd><p>Tag supplied by the client, like “OCL”, “XMA”, etc.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">*</span> <span class="pre">format</span></code></dt><dd><p>Format of Msg string to write to log file</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">...</span></code></dt><dd><p>All other arguments as per the format</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p><strong>XRT Buffer Management APIs</strong></p>
<hr class="docutils" />
<p>Buffer management APIs are used for managing device memory and migrating buffers
between host and device memory</p>
<dl class="function">
<dt id="c.xclAllocBO">
XCL_DRIVER_DLLESPEC unsigned int <code class="descname">xclAllocBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, size_t<em> size</em>, enum xclBOKind<em> domain</em>, unsigned<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclAllocBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a BO of requested size with appropriate flags</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xclBOKind</span> <span class="pre">domain</span></code></dt><dd><p>Memory domain</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>Specify bank information, etc</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>BO handle</p>
<dl class="function">
<dt id="c.xclAllocUserPtrBO">
XCL_DRIVER_DLLESPEC unsigned int <code class="descname">xclAllocUserPtrBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, void *<em> userptr</em>, size_t<em> size</em>, unsigned<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclAllocUserPtrBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate a BO using userptr provided by the user</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">userptr</span></code></dt><dd><p>Pointer to 4K aligned user memory</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of buffer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>Specify bank information, etc</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>BO handle</p>
<dl class="function">
<dt id="c.xclFreeBO">
XCL_DRIVER_DLLESPEC void <code class="descname">xclFreeBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> boHandle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclFreeBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Free a previously allocated BO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">boHandle</span></code></dt><dd><p>BO handle</p>
</dd>
</dl>
<dl class="function">
<dt id="c.xclWriteBO">
XCL_DRIVER_DLLESPEC size_t <code class="descname">xclWriteBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> boHandle</em>, const void *<em> src</em>, size_t<em> size</em>, size_t<em> seek</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclWriteBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy-in user data to host backing storage of BO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">boHandle</span></code></dt><dd><p>BO handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">src</span></code></dt><dd><p>Source data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">seek</span></code></dt><dd><p>Offset within the BO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>Copy host buffer contents to previously allocated device memory. <code class="docutils literal notranslate"><span class="pre">seek</span></code> specifies how many bytes
to skip at the beginning of the BO before copying-in <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes of host buffer.</p>
<dl class="function">
<dt id="c.xclReadBO">
XCL_DRIVER_DLLESPEC size_t <code class="descname">xclReadBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> boHandle</em>, void *<em> dst</em>, size_t<em> size</em>, size_t<em> skip</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclReadBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy-out user data from host backing storage of BO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">boHandle</span></code></dt><dd><p>BO handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">dst</span></code></dt><dd><p>Destination data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">skip</span></code></dt><dd><p>Offset within the BO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or appropriate error number</p>
<p>Copy contents of previously allocated device memory to host buffer. <code class="docutils literal notranslate"><span class="pre">skip</span></code> specifies how many bytes
to skip from the beginning of the BO before copying-out <code class="docutils literal notranslate"><span class="pre">size</span></code> bytes of device buffer.</p>
<dl class="function">
<dt id="c.xclMapBO">
XCL_DRIVER_DLLESPEC void * <code class="descname">xclMapBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> boHandle</em>, bool<em> write</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclMapBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory map BO into user’s address space</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">boHandle</span></code></dt><dd><p>BO handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">write</span></code></dt><dd><p>READ only or READ/WRITE mapping</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Memory mapped buffer</p>
<p>Map the contents of the buffer object into host memory
To unmap the buffer call POSIX <code class="xref c c-func docutils literal notranslate"><span class="pre">unmap()</span></code> on mapped void * pointer returned from xclMapBO</p>
<dl class="function">
<dt id="c.xclSyncBO">
XCL_DRIVER_DLLESPEC int <code class="descname">xclSyncBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> boHandle</em>, enum xclBOSyncDirection<em> dir</em>, size_t<em> size</em>, size_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclSyncBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronize buffer contents in requested direction</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">boHandle</span></code></dt><dd><p>BO handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xclBOSyncDirection</span> <span class="pre">dir</span></code></dt><dd><p>To device or from device</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to synchronize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">offset</span></code></dt><dd><p>Offset within the BO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or standard errno</p>
<p>Synchronize the buffer contents between host and device. Depending on the memory model this may
require DMA to/from device or CPU cache flushing/invalidation</p>
<dl class="function">
<dt id="c.xclCopyBO">
XCL_DRIVER_DLLESPEC int <code class="descname">xclCopyBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> dstBoHandle</em>, unsigned int<em> srcBoHandle</em>, size_t<em> size</em>, size_t<em> dst_offset</em>, size_t<em> src_offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclCopyBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy device buffer contents to another buffer</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">dstBoHandle</span></code></dt><dd><p>Destination BO handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">srcBoHandle</span></code></dt><dd><p>Source BO handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to synchronize</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">dst_offset</span></code></dt><dd><p>dst  Offset within the BO</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">src_offset</span></code></dt><dd><p>src  Offset within the BO</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or standard errno</p>
<p>Copy from source buffer contents to destination buffer, can be device to device or device to host.
Always perform WRITE to achieve better performance, destination buffer can be on device or host
require DMA from device</p>
<dl class="function">
<dt id="c.xclExportBO">
XCL_DRIVER_DLLESPEC int <code class="descname">xclExportBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> boHandle</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclExportBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain DMA-BUF file descriptor for a BO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">boHandle</span></code></dt><dd><p>BO handle which needs to be exported</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>File handle to the BO or standard errno</p>
<p>Export a BO for import into another device or Linux subsystem which accepts DMA-BUF fd
This operation is backed by Linux DMA-BUF framework</p>
<dl class="function">
<dt id="c.xclImportBO">
XCL_DRIVER_DLLESPEC unsigned int <code class="descname">xclImportBO</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, int<em> fd</em>, unsigned<em> flags</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclImportBO" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain BO handle for a BO represented by DMA-BUF file descriptor</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>File handle to foreign BO owned by another device which needs to be imported</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>Unused</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>BO handle of the imported BO</p>
<p>Import a BO exported by another device.     *
This operation is backed by Linux DMA-BUF framework</p>
<dl class="function">
<dt id="c.xclGetBOProperties">
XCL_DRIVER_DLLESPEC int <code class="descname">xclGetBOProperties</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> boHandle</em>, struct xclBOProperties *<em> properties</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclGetBOProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain xclBOProperties struct for a BO</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">boHandle</span></code></dt><dd><p>BO handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">xclBOProperties</span> <span class="pre">*</span> <span class="pre">properties</span></code></dt><dd><p>BO properties struct pointer</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success</p>
<p>This is the prefered method for obtaining BO property information.</p>
<p><strong>XRT Unmanaged DMA APIs</strong></p>
<hr class="docutils" />
<p>Unmanaged DMA APIs are for exclusive use by the debuggers and tools. The APIs allow clinets to read/write
from/to absolute device address. No checks are performed if a buffer was allocated before at the specified
location or if the address is valid. Users who want to take over the full memory managemnt of the device
may use this API to synchronize their buffers between host and device.</p>
<dl class="function">
<dt id="c.xclUnmgdPread">
XCL_DRIVER_DLLESPEC ssize_t <code class="descname">xclUnmgdPread</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned<em> flags</em>, void *<em> buf</em>, size_t<em> size</em>, uint64_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclUnmgdPread" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform unmanaged device memory read operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>Unused</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Destination data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt><dd><p>Absolute offset inside device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of bytes read or appropriate error number</p>
<p>This API may be used to perform DMA operation from absolute location specified. Users
may use this if they want to perform their own device memory management – not using the buffer
object (BO) framework defined before.</p>
<dl class="function">
<dt id="c.xclUnmgdPwrite">
XCL_DRIVER_DLLESPEC ssize_t <code class="descname">xclUnmgdPwrite</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned<em> flags</em>, const void *<em> buf</em>, size_t<em> size</em>, uint64_t<em> offset</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclUnmgdPwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform unmanaged device memory read operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">flags</span></code></dt><dd><p>Unused</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">buf</span></code></dt><dd><p>Source data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to copy</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt><dd><p>Absolute offset inside device</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of bytes written or appropriate error number</p>
<p>This API may be used to perform DMA operation to an absolute location specified. Users
may use this if they want to perform their own device memory management – not using the buffer
object (BO) framework defined before.</p>
<dl class="function">
<dt id="c.xclWrite">
XCL_DRIVER_DLLESPEC size_t <code class="descname">xclWrite</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, enum xclAddressSpace<em> space</em>, uint64_t<em> offset</em>, const void *<em> hostBuf</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclWrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform register write operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xclAddressSpace</span> <span class="pre">space</span></code></dt><dd><p>Address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt><dd><p>Offset in the address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">void</span> <span class="pre">*</span> <span class="pre">hostBuf</span></code></dt><dd><p>Source data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of bytes written or appropriate error number</p>
<p>This API may be used to write to device registers exposed on PCIe BAR. Offset is relative to the
the address space. A device may have many address spaces.
This API will be deprecated in future. Please use this API only for IP bringup/debugging. For
execution management please use XRT Compute Unit Execution Management APIs defined below.</p>
<dl class="function">
<dt id="c.xclRead">
XCL_DRIVER_DLLESPEC size_t <code class="descname">xclRead</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, enum xclAddressSpace<em> space</em>, uint64_t<em> offset</em>, void *<em> hostbuf</em>, size_t<em> size</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclRead" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform register read operation</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">xclAddressSpace</span> <span class="pre">space</span></code></dt><dd><p>Address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">uint64_t</span> <span class="pre">offset</span></code></dt><dd><p>Offset in the address space</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span> <span class="pre">hostbuf</span></code></dt><dd><p>Destination data pointer</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">size</span></code></dt><dd><p>Size of data to copy</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>size of bytes written or appropriate error number</p>
<p>This API may be used to read from device registers exposed on PCIe BAR. Offset is relative to the
the address space. A device may have many address spaces.
<em>This API will be deprecated in future. Please use this API only for IP bringup/debugging. For
execution management please use XRT Compute Unit Execution Management APIs defined below</em></p>
<p><strong>XRT Compute Unit Execution Management APIs</strong></p>
<p>These APIs are under development. These functions will be used to start compute
units and wait for them to finish.</p>
<dl class="function">
<dt id="c.xclExecBuf">
XCL_DRIVER_DLLESPEC int <code class="descname">xclExecBuf</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> cmdBO</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclExecBuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit an execution request to the embedded (or software) scheduler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmdBO</span></code></dt><dd><p>BO handle containing command packet</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 or standard error number</p>
<p>Submit an exec buffer for execution. The exec buffer layout is defined by struct ert_packet
which is defined in file <em>ert.h</em>. The BO should been allocated with DRM_XOCL_BO_EXECBUF flag.</p>
<dl class="function">
<dt id="c.xclExecBufWithWaitList">
XCL_DRIVER_DLLESPEC int <code class="descname">xclExecBufWithWaitList</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> cmdBO</em>, size_t<em> num_bo_in_wait_list</em>, unsigned int *<em> bo_wait_list</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclExecBufWithWaitList" title="Permalink to this definition">¶</a></dt>
<dd><p>Submit an execution request to the embedded (or software) scheduler</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">cmdBO</span></code></dt><dd><p>BO handle containing command packet</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size_t</span> <span class="pre">num_bo_in_wait_list</span></code></dt><dd><p>Number of BO handles in wait list</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">bo_wait_list</span></code></dt><dd><p>BO handles that must complete execution before cmdBO is started</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 or standard error number</p>
<p>Submit an exec buffer for execution. The BO handles in the wait
list must complete execution before cmdBO is started.  The BO
handles in the wait list must have beeen submitted prior to this
call to xclExecBufWithWaitList.</p>
<dl class="function">
<dt id="c.xclExecWait">
XCL_DRIVER_DLLESPEC int <code class="descname">xclExecWait</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, int<em> timeoutMilliSec</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclExecWait" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for one or more execution events on the device</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">timeoutMilliSec</span></code></dt><dd><p>How long to wait for</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>Same code as poll system call</p>
<p>Wait for notification from the hardware. The function essentially calls “poll” system
call on the driver file handle. The return value has same semantics as poll system call.
If return value is &gt; 0 caller should check the status of submitted exec buffers
Note that if you perform wait for the same handle from multiple threads, you
may lose wakeup for some of them. So, use different handle in different threads.</p>
<dl class="function">
<dt id="c.xclRegisterInterruptNotify">
XCL_DRIVER_DLLESPEC int <code class="descname">xclRegisterInterruptNotify</code><span class="sig-paren">(</span><a class="reference internal" href="#c.xclDeviceHandle" title="xclDeviceHandle">xclDeviceHandle</a><em> handle</em>, unsigned int<em> userInterrupt</em>, int<em> fd</em><span class="sig-paren">)</span><a class="headerlink" href="#c.xclRegisterInterruptNotify" title="Permalink to this definition">¶</a></dt>
<dd><p>register <em>eventfd</em> file handle for a MSIX interrupt</p>
</dd></dl>

<p><strong>Parameters</strong></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">xclDeviceHandle</span> <span class="pre">handle</span></code></dt><dd><p>Device handle</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span> <span class="pre">userInterrupt</span></code></dt><dd><p>MSIX interrupt number</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">fd</span></code></dt><dd><p>Eventfd handle</p>
</dd>
</dl>
<p><strong>Return</strong></p>
<p>0 on success or standard errno</p>
<p>Support for non managed interrupts (interrupts from custom IPs). fd should be obtained from
eventfd system call. Caller should use standard poll/read eventfd framework in order to wait for
interrupts. The handles are automatically unregistered on process exit.</p>
<p><strong>XRT Stream Queue APIs</strong></p>
<p>These functions are used for next generation DMA Engine, QDMA. QDMA provides not only memory
mapped DMA which moves data between host memory and board memory, but also stream DMA which moves
data between host memory and kernel directly. XDMA memory mapped DMA APIs are also supported on
QDMA. New stream APIs are provided here for preview and may be revised in a future release. These
can only be used with platforms with QDMA engine under the hood. The higher level OpenCL based
streaming APIs offer more refined interfaces and compatibility between releases.</p>
<p><strong>Performance Monitoring Operations</strong></p>
<p>These functions are used to read and write to the performance monitoring infrastructure.
OpenCL runtime will be using the BUFFER MANAGEMNT APIs described above to manage OpenCL buffers.
It would use these functions to initialize and sample the performance monitoring on the card.
Note that the offset is wrt the address space</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ert.main.html" class="btn btn-neutral float-right" title="Embedded Runtime Library" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="xma.main.html" class="btn btn-neutral float-left" title="Xilinx Media Accelerator (XMA) Core Library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2019, Xilinx, Inc

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>