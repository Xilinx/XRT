


<!DOCTYPE HTML>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
		<link rel="stylesheet" href="https://static.cloud.coveo.com/searchui/v2.4382/css/CoveoFullSearch.css"/>
		<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<meta name="description"/>
		<meta name="keywords"/>
		<meta property="og:title" content=""/>
		<meta property="og:description"/>
		<!-- favicon -->
		<link rel="icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<link rel="shortcut icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<!-- Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css"/>

  
  
  
  

  
      <script type="text/javascript" src="_static/js/jquery.min.js"></script>	
	  <script type="text/javascript" src="_static/js/gtm.js"></script>
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
    <script type="text/javascript" src="_static/js/d3dd8c60ed.js"></script>
    <script type="text/javascript" src="_static/js/common-ui-all.min.js"></script>		
    <script type="text/javascript" src="_static/js/header-footer.min.js"></script>	
    <script type="text/javascript" src="_static/js/jquery-ui.min.js"></script>	
    <script type="text/javascript" src="_static/js/CoveoJsSearch.Lazy.min.js"></script>	
    <script type="text/javascript" src="_static/js/linkid.js"></script>		
    <script type="text/javascript" src="_static/js/Searchbox.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/common-ui-all.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/header-footer.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/pro.min.css" media="all" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="XRT Native Library C++ API" href="xrt_native.main.html" />
    <link rel="prev" title="Xilinx OpenCL extension" href="opencl_extension.html" /> 
	</head>
	<body>
		<div class="xilinx-bs3"/>
		<div class="root responsivegrid">
			<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 aem-Grid--large--16 aem-Grid--xlarge--16 aem-Grid--xxlarge--16 aem-Grid--xxxlarge--16 ">
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn aem-GridColumn--default--12">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="header parbase aem-GridColumn aem-GridColumn--default--12">
								<noindex>
									<header data-component="header">
										<nav class="navbar navbar-default aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid main-nav">
													<div class="row">
														<div class="col-xs-12">
															<div class="logo-column">
																<div class="logo">
																	<a href="https://www.xilinx.com/">
																	<img src="https://www.xilinx.com/etc.clientlibs/site/clientlibs/xilinx/all/resources/imgs/header/xilinx-header-logo.svg" title="Xilinx Inc"/>
																	</a>
																</div>
															</div>
															<div class="navbar-column">
																<div class="navbar navbar-collapse collapse" id="xilinx-main-menu">
																	<div class="mobile-search-container">
																		<div id="headerSearchBox" class="headerSearch"
																			data-component="header-search" 
																			data-redirect-if-empty="false"
																			data-coveo-access-token="xxa237d4dd-f0aa-47fc-9baa-af9121851b33"
																			data-coveo-organization-id="xilinxcomprode2rjoqok">
																			<div class='coveo-search-section'>
																				<div class="CoveoAnalytics" data-search-hub="Site"></div>
																				<ul class="dropdown-menu options">
																					<li class="option" data-label="All" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-search-hub="Site">
																						<a href="#">
																						All</a>
																					</li>
																					<li data-label="Silicon Devices" data-action-link="https://www.xilinx.com//products/silicon-devices/si-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Silicon Devices</a>
																					</li>
																					<li data-label="Boards and Kits" data-action-link="https://www.xilinx.com//products/boards-and-kits/bk-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Boards and Kits</a>
																					</li>
																					<li data-label="Intellectual Property" data-action-link="https://www.xilinx.com//products/intellectual-property/ip-keyword-search.html" data-search-hub="Product">
																						<a href="#">
																						Intellectual Property</a>
																					</li>
																					<li data-label="Support" class="option" data-action-link="https://www.xilinx.com/search/support-keyword-search.html" data-search-hub="Support">
																						<a href="#">
																						Support</a>
																						<ul>
																							<li data-label="Documentation" data-action-link="https://www.xilinx.com//support/documentation-navigation/documentation-keyword-search.html" data-search-hub="Document">
																								<a href="#">
																								Documentation</a>
																							</li>
																							<li data-label="Knowledge Base" data-action-link="https://www.xilinx.com//support/answer-navigation/answer-keyword-search.html" data-search-hub="AnswerRecord">
																								<a href="#">
																								Knowledge Base</a>
																							</li>
																							<li data-label="Community Forums" data-action-link="https://www.xilinx.com/search/forums-keyword-search.html" data-search-hub="Forums">
																								<a href="#">
																								Community Forums</a>
																							</li>
																						</ul>
																					</li>
																					<li data-label="Partners" data-action-link="https://www.xilinx.com//alliance/member-keyword-search.html" data-search-hub="Partner">
																						<a href="#">
																						Partners</a>
																					</li>
																					<li data-label="Videos" data-action-link="https://www.xilinx.com/video/video-keyword-search.html" data-search-hub="Video">
																						<a href="#">
																						Videos</a>
																					</li>
																					<li data-label="Press" data-action-link="https://www.xilinx.com/search/press-keyword-search.html" data-search-hub="Press">
																						<a href="#">
																						Press</a>
																					</li>
																				</ul>
																				<a href="#" class="btn dropdown-toggle value" data-toggle="dropdown"></a>
																				<div class="CoveoSearchbox" data-id="coveosearchbox" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-placeholder="Search Xilinx"></div>
																			</div>
																		</div>
																	</div>
																	<ul class="nav navbar-nav nav-justified">
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/applications.html">
																			Applications</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/products/silicon-devices.html">
																			Products</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://developer.xilinx.com/">
																			Developers</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/support.html">
																			Support</a> 
																		</li>
																		<li class="accordion-toggle-icons" data-component="toggle-dropdown">
																			<a href="https://www.xilinx.com/about/company-overview.html">
																			About</a> 
																		</li>
																	</ul>
																</div>
															</div>
															<script type="text/javascript" src="_static/js/gtm.js"></script>
															<!--<div class="mini-nav">
																<button type="button" data-function="xilinx-mobile-menu" id="nav-toggle" class="navbar-toggle collapsed visible-xs-block" aria-expanded="false">
																<span></span>
																<span></span>
																<span></span>
																<span></span>
																</button>
																<ul class="list-inline">
																	<li class="dropdown user-menu">
																		<button data-toggle="dropdown">
																		<span class="sr-only">Account</span>
																		<span class="fas fa-user"></span>
																		</button>
																		<ul class="dropdown-menu">
																			<li>
																				<a href="https://www.xilinx.com/myprofile/subscriptions.html">
																				My Account</a>
																			</li>
																			<li>
																				<a href="https://www.xilinx.com/registration/create-account.html">
																				Create Account</a>
																			</li>
																			<li>
																				<a href="https://www.xilinx.com/bin/protected/en/signout">
																				Sign Out</a>
																			</li>
																		</ul>
																	</li>
																	<li class="hidden-xs">
																		<button data-function="search-toggle">
																		<span class="sr-only">Search</span>
																		<span class="far fa-search"></span>
																		</button>
																	</li>
																</ul>
															</div>
															-->
															<div class="search-container">
																<div id="headerSearchBox" class="headerSearch"
																	data-component="header-search" 
																	data-redirect-if-empty="false"
																	data-coveo-access-token="xxa237d4dd-f0aa-47fc-9baa-af9121851b33"
																	data-coveo-organization-id="xilinxcomprode2rjoqok">
																	<div class='coveo-search-section'>
																		<div class="CoveoAnalytics" data-search-hub="Site"></div>
																		<ul class="dropdown-menu options">
																			<li class="option" data-label="All" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-search-hub="Site">
																				<a href="#">
																				All</a>
																			</li>
																			<li data-label="Silicon Devices" data-action-link="https://www.xilinx.com/products/silicon-devices/si-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Silicon Devices</a>
																			</li>
																			<li data-label="Boards and Kits" data-action-link="https://www.xilinx.com/products/boards-and-kits/bk-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Boards and Kits</a>
																			</li>
																			<li data-label="Intellectual Property" data-action-link="https://www.xilinx.com/products/intellectual-property/ip-keyword-search.html" data-search-hub="Product">
																				<a href="#">
																				Intellectual Property</a>
																			</li>
																			<li data-label="Support" class="option" data-action-link="https://www.xilinx.com/search/support-keyword-search.html" data-search-hub="Support">
																				<a href="#">
																				Support</a>
																				<ul>
																					<li data-label="Documentation" data-action-link="https://www.xilinx.com/support/documentation-navigation/documentation-keyword-search.html" data-search-hub="Document">
																						<a href="#">
																						Documentation</a>
																					</li>
																					<li data-label="Knowledge Base" data-action-link="https://www.xilinx.com/support/answer-navigation/answer-keyword-search.html" data-search-hub="AnswerRecord">
																						<a href="#">
																						Knowledge Base</a>
																					</li>
																					<li data-label="Community Forums" data-action-link="https://www.xilinx.com/search/forums-keyword-search.html" data-search-hub="Forums">
																						<a href="#">
																						Community Forums</a>
																					</li>
																				</ul>
																			</li>
																			<li data-label="Partners" data-action-link="https://www.xilinx.com/alliance/member-keyword-search.html" data-search-hub="Partner">
																				<a href="#">
																				Partners</a>
																			</li>
																			<li data-label="Videos" data-action-link="https://www.xilinx.com/video/video-keyword-search.html" data-search-hub="Video">
																				<a href="#">
																				Videos</a>
																			</li>
																			<li data-label="Press" data-action-link="https://www.xilinx.com/search/press-keyword-search.html" data-search-hub="Press">
																				<a href="#">
																				Press</a>
																			</li>
																		</ul>
																		<a href="#" class="btn dropdown-toggle value" data-toggle="dropdown"></a>
																		<div class="CoveoSearchbox" data-id="coveosearchbox" data-action-link="https://www.xilinx.com/search/site-keyword-search.html" data-placeholder="Search Xilinx"></div>
																	</div>
																</div>
																<button data-function="search-toggle">
																<span class="sr-only">Search</span>
																<span class="far fa-times"></span>
																</button>
															</div>
														</div>
													</div>
												</div>
											</div>
										</nav>
									</header>
								</noindex>
							</div>
						</div>
					</div>
				</div>
				<div class="parsys aem-GridColumn--xxxlarge--none aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
						<div class="container-fluid">
							<div class="row">
							<div class="col-xs-12">
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> XRT
          

          
          </a>

          
            
            
              <div class="version">
                2020.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">XRT and Vitis™ Platform Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_requirements.html">System Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="build.html">Building the XRT Software Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">XRT Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Use Model and Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="execution-model.html">Execution Model Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_kernel_executions.html">Supported Kernel Execution Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocess.html">Multi-Process Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="p2p.html">PCIe Peer-to-Peer (P2P)</a></li>
<li class="toctree-l1"><a class="reference internal" href="m2m.html">Memory-to-Memory (M2M)</a></li>
<li class="toctree-l1"><a class="reference internal" href="sb.html">PCIe Slave-Bridge (SB)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_ini.html">Configuration File xrt.ini</a></li>
</ul>
<p class="caption"><span class="caption-text">Video Acceleration Using XMA</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xma_user_guide.html">Xilinx Media Accelerator (XMA)</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma_19.2.html">XMA 19.2 Migration</a></li>
</ul>
<p class="caption"><span class="caption-text">User API Library</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="opencl_extension.html">Xilinx OpenCL extension</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">XRT Native APIs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#device-and-xclbin">Device and XCLBIN</a></li>
<li class="toctree-l2"><a class="reference internal" href="#buffers">Buffers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#buffer-allocation-and-deallocation">1. Buffer allocation and deallocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-transfer-using-buffers">2. Data transfer using Buffers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api">I. Data transfer between host and device by Buffer read/write API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api">II. Data transfer between host and device by Buffer map API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iii-data-transfer-between-the-buffers-by-copy-api">III. Data transfer between the buffers by copy API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#miscellaneous-other-buffer-apis">3. Miscellaneous other Buffer APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dma-buf-api">DMA-BUF API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sub-buffer-support">Sub-buffer support</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buffer-information">Buffer information</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#kernel-and-run">Kernel and Run</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#obtaining-kernel-handle-object-from-xclbin">Obtaining kernel handle/object from XCLBIN</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#exclusive-access-of-the-kernel-s-cu">Exclusive access of the kernel’s CU</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#getting-bank-group-index-of-the-kernel-argument">Getting bank group index of the kernel argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-write-cu-mapped-registers">Reading and write CU mapped registers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#obtaining-the-argument-offset">Obtaining the argument offset</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#executing-the-kernel">Executing the kernel</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-kernel-execution-related-apis">Other kernel execution related APIs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html">XRT Native Library C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt_native.main.html#id1">XRT Native Library C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="xma.main.html">XMA Core Library</a></li>
</ul>
<p class="caption"><span class="caption-text">XRT Developer's Space</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sysfs.html">Linux Sys FileSystem Nodes</a></li>
<li class="toctree-l1"><a class="reference internal" href="formats.html">Binary Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="xrt.main.html">XRT Core Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="ert.main.html">Embedded Runtime Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="mgmt-ioctl.main.html">XCLMGMT (PCIe Management Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="xocl_ioctl.main.html">XOCL (PCIe User Physical Function) Driver Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="zocl_ioctl.main.html">ZOCL Driver Interfaces</a></li>
</ul>
<p class="caption"><span class="caption-text">Tools and Utilities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="xclbintools.html">xclbinutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbutil.html">xbutil</a></li>
<li class="toctree-l1"><a class="reference internal" href="xbmgmt.html">xbmgmt</a></li>
</ul>
<p class="caption"><span class="caption-text">Building Platforms</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="yocto.html">XRT Setup for Embedded Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="test.html">Developer Build and Test Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">Cloud Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="mailbox.main.html">Mailbox Subdevice Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="mailbox.proto.html">Mailbox Inter-domain Communication Protocol</a></li>
<li class="toctree-l1"><a class="reference internal" href="cloud_vendor_support.html">MSD/MPD and Plugins</a></li>
</ul>
<p class="caption"><span class="caption-text">Security</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="security.html">Security of Alveo Platform</a></li>
</ul>
<p class="caption"><span class="caption-text">Debug and Faqs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="debug-faq.html">XRT/Board Debug FAQ</a></li>
</ul>

            
			<p class="caption"><span class="caption-text">This Page</span></p>
				<ul class="current">
				  <li class="toctree-l1"><a href="_sources/xrt_native_apis.rst.txt"
						rel="nofollow">Show Source</a></li>
					<li class="toctree-l1"><a href="https://github.com/Xilinx/XRT/blob/master/src/runtime_src/doc/toc/xrt_native_apis.rst"
						   rel="nofollow">View on GitHub</a></li>						
				</ul>
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">XRT</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>XRT Native APIs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/xrt_native_apis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="xrt-native-apis">
<span id="xrt-native-apis-rst"></span><h1>XRT Native APIs<a class="headerlink" href="#xrt-native-apis" title="Permalink to this headline">¶</a></h1>
<p>From 2020.2 release XRT provides a new XRT API set in C, C++, and Python flavor. This document introduces the usability of C and C++ APIs.</p>
<p>To use the native XRT APIs, the host application must link with the <strong>xrt_coreutil</strong> library.</p>
<p>Example g++ command</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>g++ -g -std<span class="o">=</span>c++14 -I<span class="nv">$XILINX_XRT</span>/include -L<span class="nv">$XILINX_XRT</span>/lib -o host.exe host.cpp -lxrt_coreutil -pthread
</pre></div>
</div>
<p>The core data structures in C and C++ are as below</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 31%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>C++ Class</p></th>
<th class="head"><p>C Type (Handle)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Device</p></td>
<td><p>xrt::device</p></td>
<td><p>xrtDeviceHandle</p></td>
</tr>
<tr class="row-odd"><td><p>XCLBIN</p></td>
<td><p>xrt::xclbin</p></td>
<td><p>xrtXclbinHandle</p></td>
</tr>
<tr class="row-even"><td><p>Buffer</p></td>
<td><p>xrt::bo</p></td>
<td><p>xrtBufferHandle</p></td>
</tr>
<tr class="row-odd"><td><p>Kernel</p></td>
<td><p>xrt::kernel</p></td>
<td><p>xrtKernelHandle</p></td>
</tr>
<tr class="row-even"><td><p>Run</p></td>
<td><p>xrt::run</p></td>
<td><p>xrtRunHandle</p></td>
</tr>
</tbody>
</table>
<p>All the core data structures are defined inside in the header files at <code class="docutils literal notranslate"><span class="pre">$XILINX_XRT/include/experimental/</span></code> directory. In the user host code, it is sufficient to include only <code class="docutils literal notranslate"><span class="pre">&quot;experimental/xrt_kernel.h&quot;</span></code> to access all the APIs related to these data structure.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>5</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="cp">#include</span> <span class="cpf">&quot;experimental/xrt_kernel.h&quot;</span><span class="cp"></span>
</pre></div>
</td></tr></table></div>
<p>The common host code flow using the above data structures is as below</p>
<blockquote>
<div><ul class="simple">
<li><p>Open Xilinx <strong>Device</strong> and Load the <strong>XCLBIN</strong></p></li>
<li><p>Set up the <strong>Buffers</strong> that are used to transfer the data between the host and the device</p></li>
<li><p>Use the Buffer APIs for the data transfer between host and device (before and after the kernel execution).</p></li>
<li><p>Use <strong>Kernel</strong> and <strong>Run</strong> handle/objects to offload and manage the compute-intensive tasks running on FPGA.</p></li>
</ul>
</div></blockquote>
<p>Below we will walk through the common API usage to accomplish the above tasks.</p>
<div class="section" id="device-and-xclbin">
<h2>Device and XCLBIN<a class="headerlink" href="#device-and-xclbin" title="Permalink to this headline">¶</a></h2>
<p>Device and XCLBIN class provide fundamental infrastructure-related interfaces. The primary objective of the device and XCLBIN related APIs are</p>
<blockquote>
<div><ul class="simple">
<li><p>Open a Device</p></li>
<li><p>Load compiled kernel binary (or XCLBIN) onto the device</p></li>
</ul>
</div></blockquote>
<p>Example C API based code</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xrtDeviceHandle</span> <span class="n">device</span> <span class="o">=</span> <span class="n">xrtDeviceOpen</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

     <span class="n">xrtXclbinHandle</span> <span class="n">xclbin</span> <span class="o">=</span> <span class="n">xrtXclbinAllocFilename</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span>

     <span class="n">xrtDeviceLoadXclbinHandle</span><span class="p">(</span><span class="n">device</span><span class="p">,</span><span class="n">xclbin</span><span class="p">);</span>
     <span class="p">..............</span>
     <span class="p">..............</span>
     <span class="n">xrtDeviceClose</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>The above code block shows</p>
<blockquote>
<div><ul>
<li><p>Opening the device (enumerated as 0) and get device handle <code class="docutils literal notranslate"><span class="pre">xrtDeviceHandle</span></code> (line 10)</p>
<blockquote>
<div><ul class="simple">
<li><p>Device indices are enumerated as 0,1,2 and can be observed by <code class="docutils literal notranslate"><span class="pre">xbutil</span> <span class="pre">scan</span></code></p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&gt;&gt;xbutil scan
INFO: Found total 2 card(s), 2 are usable
.............
[0] 0000:b3:00.1 xilinx_u250_gen3x16_base_1 user(inst=129)
[1] 0000:65:00.1 xilinx_u50_gen3x16_base_1 user(inst=128)
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Opening the XCLBIN from the filename and get an XCLBIN handle <code class="docutils literal notranslate"><span class="pre">xrtXclbinHandle</span></code> (line 12)</p></li>
<li><p>Loading the XCLBIN onto the Device by using the XCLBIN handle by API <code class="docutils literal notranslate"><span class="pre">xrtDeviceLoadXclbinHandle</span></code> (line 14)</p></li>
<li><p>Closing the device handle at the end of the application (line 19)</p></li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">auto</span> <span class="n">device</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">device</span><span class="p">(</span><span class="n">dev_index</span><span class="p">);</span>
     <span class="k">auto</span> <span class="n">xclbin_uuid</span> <span class="o">=</span> <span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>The above code block shows</p>
<blockquote>
<div><ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">xrt::device</span></code> class’s constructor is used to open the device</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> is used to load the XCLBIN from the filename.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::device::load_xclbin</span></code> returns the XCLBIN UUID, which is required to open the kernel (refer the Kernel Section).</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="buffers">
<h2>Buffers<a class="headerlink" href="#buffers" title="Permalink to this headline">¶</a></h2>
<p>Buffers are primarily used to transfer the data between the host and the device. The Buffer related APIs are discussed in the following three subsections</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Buffer allocation and deallocation</p></li>
<li><p>Data transfer using Buffers</p></li>
<li><p>Miscellaneous other Buffer APIs</p></li>
</ol>
</div></blockquote>
<div class="section" id="buffer-allocation-and-deallocation">
<h3>1. Buffer allocation and deallocation<a class="headerlink" href="#buffer-allocation-and-deallocation" title="Permalink to this headline">¶</a></h3>
<p>XRT APIs provides API for</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOAlloc</span></code>: Allocates a buffer object 4K aligned, the API must be called with appropriate flags.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOAllocUserPtr</span></code>: Allocates a buffer object using pointer provided by the user. The user pointer must be aligned to 4K boundary.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOFree</span></code>: Deallocates the allocated buffer.</p></li>
</ul>
</div></blockquote>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xrtMemoryGroup</span> <span class="n">bank_grp_idx_0</span> <span class="o">=</span> <span class="n">xrtKernelArgGroupId</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
     <span class="n">xrtMemoryGroup</span> <span class="n">bank_grp_idx_1</span> <span class="o">=</span> <span class="n">xrtKernelArgGroupId</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

     <span class="n">xrtBufferHandle</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrtBOAlloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">XRT_BO_FLAGS_NONE</span><span class="p">,</span> <span class="n">bank_grp_idx_0</span><span class="p">);</span>
     <span class="n">xrtBufferHandle</span> <span class="n">output_buffer</span> <span class="o">=</span> <span class="n">xrtBOAlloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">XRT_BO_FLAGS_NONE</span><span class="p">,</span> <span class="n">bank_grp_idx_1</span><span class="p">);</span>

     <span class="p">....</span>
     <span class="p">....</span>
     <span class="n">xrtBOFree</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>
     <span class="n">xrtBOFree</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>The above code block shows</p>
<blockquote>
<div><ul class="simple">
<li><p>Buffer allocation API <code class="docutils literal notranslate"><span class="pre">xrtBOAlloc</span></code> at lines 15,16</p></li>
<li><p>Buffer deallocation API <code class="docutils literal notranslate"><span class="pre">xrtBOFree</span></code> at lines 23,24</p></li>
</ul>
</div></blockquote>
<p>The various arguments of the API <code class="docutils literal notranslate"><span class="pre">xrtBOAlloc</span></code> are</p>
<blockquote>
<div><ul>
<li><p>Argument 1: The device on which the buffer should be allocated</p></li>
<li><p>Argument 2: The size (in bytes) of the buffer</p></li>
<li><p>Argument 3: <code class="docutils literal notranslate"><span class="pre">xrtBufferFlags</span></code>: Used to specify the buffer type, most commonly used types are</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_NONE</span></code>: Regular Buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_DEV_ONLY</span></code>: Device only Buffer (meant to be used only by the kernel).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_HOST_ONLY</span></code>: Host Only Buffer (buffers reside in the host memory directly transferred to/from the kernel)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_P2P</span></code>: P2P Buffer, buffer for NVMe transfer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">XRT_BO_FLAGS_CACHEABLE</span></code>: Cacheable buffer can be used when host CPU frequently accessing the buffer (applicable for embedded platform).</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Argument 4:  <code class="docutils literal notranslate"><span class="pre">xrtMemoryGroup</span></code>: Enumerated Memory Bank to specify the location on the device where the buffer should be allocated. The <code class="docutils literal notranslate"><span class="pre">xrtMemoryGroup</span></code> is obtained by the API <code class="docutils literal notranslate"><span class="pre">xrtKernelArgGroupId</span></code> as shown in line 15 (for more details of this API refer to the Kernel section).</p></li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">auto</span> <span class="n">bank_grp_idx_0</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
     <span class="k">auto</span> <span class="n">bank_grp_idx_1</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span><span class="n">bank_grp_idx_0</span><span class="p">);</span>
     <span class="k">auto</span> <span class="n">output_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">bank_grp_idx_1</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>In the above code <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> buffer objects are created using the class’s constructor. Note the buffer flag is not used as constructor by default created regular buffer. Nonetheless, the available buffer flags for <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> are described using <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> argument with the following enumerator values</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::normal</span></code>: Default, Regular Buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::device_only</span></code>: Device only Buffer (meant to be used only by the kernel).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::host_only</span></code>: Host Only Buffer (buffer resides in the host memory directly transferred to/from the kernel)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::p2p</span></code>: P2P Buffer, buffer for NVMe transfer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::flags::cacheable</span></code>: Cacheable buffer can be used when host CPU frequently accessing the buffer (applicable for embedded platform).</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="data-transfer-using-buffers">
<h3>2. Data transfer using Buffers<a class="headerlink" href="#data-transfer-using-buffers" title="Permalink to this headline">¶</a></h3>
<p>XRT Buffer API library provides a rich set of APIs helping the data transfers between the host and the device, between the buffers, etc. We will discuss the following data transfer style</p>
<blockquote>
<div><ol class="upperroman simple">
<li><p>Data transfer between host and device by Buffer read/write API</p></li>
<li><p>Data transfer between host and device by Buffer map API</p></li>
<li><p>Data transfer between buffers by copy API</p></li>
</ol>
</div></blockquote>
<div class="section" id="i-data-transfer-between-host-and-device-by-buffer-read-write-api">
<h4>I. Data transfer between host and device by Buffer read/write API<a class="headerlink" href="#i-data-transfer-between-host-and-device-by-buffer-read-write-api" title="Permalink to this headline">¶</a></h4>
<p>To transfer the data from the host to the device, the user first needs to update the host-side buffer backing pointer followed by a DMA transfer to the device.</p>
<p>The following C APIs are used for the above tasks</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOWrite</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOSync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_TO_DEVICE</span></code></p></li>
</ol>
</div></blockquote>
<p>In C++, <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class has following member functions for the same functionality</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_TO_DEVICE</span></code></p></li>
</ol>
</div></blockquote>
<p>To transfer the data from the device to the host, the steps are reverse, the user first needs to do a DMA transfer from the device followed by the reading data from the host-side buffer backing pointer.</p>
<p>The following C APIs are used for the above tasks</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOSync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_FROM_DEVICE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBORead</span></code></p></li>
</ol>
</div></blockquote>
<p>In C++ the corresponding <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class’s member functions are</p>
<blockquote>
<div><ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code> with flag <code class="docutils literal notranslate"><span class="pre">XCL_BO_SYNC_BO_FROM_DEVICE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code></p></li>
</ol>
</div></blockquote>
<p>Code example of transferring data from the host to the device</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xrtBufferHandle</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrtBOAlloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">XRT_BO_FLAGS_NONE</span><span class="p">,</span> <span class="n">bank_grp_idx_0</span><span class="p">);</span>

     <span class="c1">// Prepare the input data</span>
     <span class="kt">int</span> <span class="n">buff_data</span><span class="p">[</span><span class="n">data_size</span><span class="p">];</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">buff_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="n">xrtBOWrite</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span><span class="n">buff_data</span><span class="p">,</span><span class="n">data_size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>
     <span class="n">xrtSyncBO</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">,</span> <span class="n">data_size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">bank_grp_idx_0</span><span class="p">);</span>
     <span class="c1">// Prepare the input data</span>
     <span class="kt">int</span> <span class="n">buff_data</span><span class="p">[</span><span class="n">data_size</span><span class="p">];</span>
     <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">buff_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="n">input_buffer</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buff_data</span><span class="p">);</span>
     <span class="n">input_buffer</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Note the C++ <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::write</span></code>, <code class="docutils literal notranslate"><span class="pre">xrt::bo::read</span></code> etc has overloaded version that can be used for paritial buffer sync/read/write by specifying the size and the offset. For the above code example, the full buffer size and 0 offset are used as default arguments.</p>
</div>
<div class="section" id="ii-data-transfer-between-host-and-device-by-buffer-map-api">
<h4>II. Data transfer between host and device by Buffer map API<a class="headerlink" href="#ii-data-transfer-between-host-and-device-by-buffer-map-api" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrtBOMap</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::map</span></code>) allows mapping the host-side buffer backing pointer to a user pointer. The host code can subsequently exercise the user pointer for the data reads and writes. However, after writing to the mapped pointer (or before reading from the mapped pointer) the API <code class="docutils literal notranslate"><span class="pre">xrtBOSync</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::sync</span></code>) should be used with direction flag for the DMA operation.</p>
<p>Code example of transferring data from the host to the device by this approach</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xrtBufferHandle</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrtBOAlloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">XRT_BO_FLAGS_NONE</span><span class="p">,</span> <span class="n">bank_grp_idx_0</span><span class="p">);</span>
     <span class="kt">int</span><span class="o">*</span> <span class="n">input_buffer_mapped</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">xrtBOMap</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">);</span>

     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">input_buffer_mappped</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="n">xrtBOSync</span><span class="p">(</span><span class="n">input_buffer</span><span class="p">,</span> <span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">bank_grp_idx_0</span><span class="p">);</span>
     <span class="k">auto</span> <span class="n">input_buffer_mapped</span> <span class="o">=</span> <span class="n">input_buffer</span><span class="p">.</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">();</span>

     <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">data_size</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">input_buffer_mapped</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="n">input_buffer</span><span class="p">.</span><span class="n">sync</span><span class="p">(</span><span class="n">XCL_BO_SYNC_BO_TO_DEVICE</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="iii-data-transfer-between-the-buffers-by-copy-api">
<h4>III. Data transfer between the buffers by copy API<a class="headerlink" href="#iii-data-transfer-between-the-buffers-by-copy-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides <code class="docutils literal notranslate"><span class="pre">xrtBOCopy</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy</span></code>) API for deep copy between the two buffer objects if the platform supports a deep-copy (for detail refer M2M feature described in <a class="reference internal" href="m2m.html#m2m-rst"><span class="std std-ref">Memory-to-Memory (M2M)</span></a>). If deep copy is not supported by the platform the data transfer happens by shallow copy (the data transfer happens via host).</p>
<p>API Example in C, all arguments are self-explanatory</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="kt">size_t</span> <span class="n">dst_buffer_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="kt">size_t</span> <span class="n">src_buffer_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="n">xrtBOCopy</span><span class="p">(</span><span class="n">dst_buffer</span><span class="p">,</span> <span class="n">src_buffer</span><span class="p">,</span> <span class="n">size_of_copy</span><span class="p">,</span> <span class="n">dst_buffer_offset</span><span class="p">,</span> <span class="n">src_buffer_offset</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>25</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">dst_buffer</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">src_buffer</span><span class="p">,</span> <span class="n">copy_size_in_bytes</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrt::bo::copy</span></code> also has overloaded version to provide a different offset than 0 for both the source and the destination buffer.</p>
</div>
</div>
<div class="section" id="miscellaneous-other-buffer-apis">
<h3>3. Miscellaneous other Buffer APIs<a class="headerlink" href="#miscellaneous-other-buffer-apis" title="Permalink to this headline">¶</a></h3>
<p>This section describes a few other specific use-cases using buffers.</p>
<div class="section" id="dma-buf-api">
<h4>DMA-BUF API<a class="headerlink" href="#dma-buf-api" title="Permalink to this headline">¶</a></h4>
<p>XRT provides Buffer export and import APIs primarily used for sharing buffer across devices (P2P application) and processes.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOExport</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer</span></code>): Export the buffer to an exported buffer handle</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOImport</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> constructor) : Allocate a BO imported from exported buffer handle</p></li>
</ul>
</div></blockquote>
<p>Consider the situation of exporting buffer from device 1 to device 2.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xclBufferExportHandle</span> <span class="n">buffer_exported</span> <span class="o">=</span> <span class="n">xrtBOExport</span><span class="p">(</span><span class="n">buffer_device_1</span><span class="p">);</span>
     <span class="n">xrtBufferHandle</span> <span class="n">buffer_device_2</span> <span class="o">=</span> <span class="n">xrtBOImport</span><span class="p">(</span><span class="n">device_2</span><span class="p">,</span> <span class="n">buffer_exported</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>In the above example</p>
<blockquote>
<div><ul class="simple">
<li><p>The buffer buffer_device_1 is a buffer allocated on device 1</p></li>
<li><p>buffer_device_1 is exported to an <code class="docutils literal notranslate"><span class="pre">xclBufferExportHandle</span></code> by API <code class="docutils literal notranslate"><span class="pre">xrtBOExport</span></code></p></li>
<li><p>The exported buffer of type <code class="docutils literal notranslate"><span class="pre">xclBufferExportHandle</span></code> is imported to device 2 by API <code class="docutils literal notranslate"><span class="pre">xrtBOImport</span></code></p></li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">auto</span> <span class="n">buffer_exported</span> <span class="o">=</span> <span class="n">buffer_device_1</span><span class="p">.</span><span class="n">export_buffer</span><span class="p">();</span>
     <span class="k">auto</span> <span class="n">buffer_device_2</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device_2</span><span class="p">,</span> <span class="n">buffer_exported</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>In the above example</p>
<blockquote>
<div><ul class="simple">
<li><p>The buffer buffer_device_1 is a buffer allocated on device 1</p></li>
<li><p>buffer_device_1 is exported by the member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::export_buffer</span></code></p></li>
<li><p>The new buffer buffer_device_2 is imported for device_2 by the constructor <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code></p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="sub-buffer-support">
<h4>Sub-buffer support<a class="headerlink" href="#sub-buffer-support" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrtBOSubAlloc</span></code> (C++: supported by an <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> class constructor) allocates a sub-buffer from a parent buffer by specifying a start offset and the size.</p>
<p>In the example below a sub-buffer is created from a parent buffer of size 4 bytes staring from its offset 0</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xrtBufferHandle</span> <span class="n">parent_buffer</span><span class="p">;</span>
     <span class="n">xrtBufferHandle</span> <span class="n">sub_buffer</span><span class="p">;</span>

     <span class="kt">size_t</span> <span class="n">sub_buffer_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
     <span class="kt">size_t</span> <span class="n">sub_buffer_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

     <span class="n">sub_buffer</span> <span class="o">=</span> <span class="n">xrtBOSubAlloc</span><span class="p">(</span><span class="n">parent_buffer</span><span class="p">,</span> <span class="n">sub_buffer_size</span><span class="p">,</span> <span class="n">sub_buffer_offset</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><strong>C++</strong>: The equivalent C++ API based code</p>
<p>In C++ a sub-buffer is created by using the xrt::bo class’s constructor using the parent buffer, size, and offset as parameters.</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="kt">size_t</span> <span class="n">sub_buffer_size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
     <span class="kt">size_t</span> <span class="n">sub_buffer_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

     <span class="k">auto</span> <span class="n">sub_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">parent_buffer</span><span class="p">,</span> <span class="n">sub_buffer_size</span><span class="p">,</span> <span class="n">sub_buffer_offset</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="buffer-information">
<h4>Buffer information<a class="headerlink" href="#buffer-information" title="Permalink to this headline">¶</a></h4>
<p>XRT provides few other APIs to obtain information related to the buffer.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOSize</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::size</span></code>): Size of the buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrtBOAddr</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::bo::address</span></code>) : Physical address of the buffer</p></li>
</ul>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="kernel-and-run">
<h2>Kernel and Run<a class="headerlink" href="#kernel-and-run" title="Permalink to this headline">¶</a></h2>
<p>The XRT kernel APIs support creating of kernel handle (or object in C++) from currently loaded xclbin.  The kernel handle is used to execute the kernel function on the hardware instance (Compute Unit or CU) of the kernel.</p>
<p>A Run handle/object represents an execution of the kernel. Upon finishing the kernel execution, the Run handle/object can be reused to invoke the same kernel function if desired.</p>
<p>The following topics are discussed below</p>
<blockquote>
<div><ul class="simple">
<li><p>Obtaining kernel handle/object from XCLBIN</p></li>
<li><p>Getting the bank group index of a kernel argument</p></li>
<li><p>Reading and write CU mapped registers</p></li>
<li><p>Execution of kernel and dealing with the associated run</p></li>
<li><p>Other kernel execution related API</p></li>
</ul>
</div></blockquote>
<div class="section" id="obtaining-kernel-handle-object-from-xclbin">
<h3>Obtaining kernel handle/object from XCLBIN<a class="headerlink" href="#obtaining-kernel-handle-object-from-xclbin" title="Permalink to this headline">¶</a></h3>
<p>The kernel handle (or object) is created from the device, XCLBIN UUID and the kernel name.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xuid_t</span> <span class="n">xclbin_uuid</span><span class="p">;</span>
     <span class="n">xrtXclbinGetUUID</span><span class="p">(</span><span class="n">xclbin</span><span class="p">,</span><span class="n">xclbin_uuid</span><span class="p">);</span>

     <span class="n">xrtKernelHandle</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">xrtPLKernelOpen</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;kernel_name&quot;</span><span class="p">);</span>
     <span class="p">....</span>
     <span class="p">....</span>
     <span class="n">xrtKernelClose</span><span class="p">(</span><span class="n">kernel</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>In the above code example</p>
<blockquote>
<div><ul class="simple">
<li><p>The UUID of the XCLBIN is retrieved by the API <code class="docutils literal notranslate"><span class="pre">xrtXclbinGetUUID</span></code></p></li>
<li><p>The kernel is created by the API <code class="docutils literal notranslate"><span class="pre">xrtPLKernelOpen</span></code></p></li>
<li><p>The kernel is closed by the API <code class="docutils literal notranslate"><span class="pre">xrtKernelClose</span></code></p></li>
</ul>
</div></blockquote>
<p><strong>Note</strong>: For the kernel with more than 1 CU, a kernel handle (or object) should represent all the CUs having identical interface connectivity. If all the CUs of the kernel are not having identical connectivity, the specific CU name(s) should be used to obtain a kernel handle (or object) to represent the subset of CUs with identical connectivity. Otherwise XRT will do this selection internally to select a group of CUs and discard the rest of the CUs (discarded CUs are not used during the execution of a kernel).</p>
<p>As an example, assume a kernel name is foo having 3 CUs foo_1, foo_2, foo_3. The CUs foo_1 and foo_2 are connected to DDR bank 0, but the CU foo_3 is connected to DDR bank 1.</p>
<blockquote>
<div><ul>
<li><p>Opening kernel handle for foo_1 and foo_2 (as they have identical interface connection)</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">cu_group_1</span> <span class="o">=</span> <span class="n">xrtPLKernelOpen</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;foo:{foo_1,foo_2}&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p>Opening kernel handle for foo_3</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">cu_group_2</span> <span class="o">=</span> <span class="n">xrtPLKernelOpen</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;foo:{foo_3}&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: In C++, <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> object can be created from the constructor of <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> class.</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">auto</span> <span class="n">xclbin_uuid</span> <span class="o">=</span> <span class="n">device</span><span class="p">.</span><span class="n">load_xclbin</span><span class="p">(</span><span class="s">&quot;kernel.xclbin&quot;</span><span class="p">);</span>
     <span class="k">auto</span> <span class="n">krnl</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="exclusive-access-of-the-kernel-s-cu">
<h4>Exclusive access of the kernel’s CU<a class="headerlink" href="#exclusive-access-of-the-kernel-s-cu" title="Permalink to this headline">¶</a></h4>
<p>The API <code class="docutils literal notranslate"><span class="pre">xrtPLKernelOpen</span></code> opens a kernel’s CU in a shared mode so that the CU can be shared with the other processes. In some cases, it is required to open the CU in exclusive mode (for example, when it is required to read/write CU mapped register). Exclusive CU opening fails if the CU is already opened in either shared or exclusive access.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>39</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xrtKernelHandle</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">xrtPLKernelOpenExclusive</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><strong>C++</strong>: In C++, <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> constructor can be called with an additional <code class="docutils literal notranslate"><span class="pre">enum</span> <span class="pre">class</span></code> argument to access the kernel in exclusive mode. The enumerator values are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::kernel::cu_access_mode::shared</span></code> (default <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> constructor argument)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrt::kernel::cu_access_mode::exclusive</span></code></p></li>
</ul>
</div></blockquote>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>39</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">auto</span> <span class="n">krnl</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="o">::</span><span class="n">cu_access_mode</span><span class="o">::</span><span class="n">exclusive</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="getting-bank-group-index-of-the-kernel-argument">
<h3>Getting bank group index of the kernel argument<a class="headerlink" href="#getting-bank-group-index-of-the-kernel-argument" title="Permalink to this headline">¶</a></h3>
<p>We have seen in the Buffer creation section that it is required to provide the buffer location during the buffer creation. XRT provides an API <code class="docutils literal notranslate"><span class="pre">xrtKernelArgGroupId</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::kernel::group_id</span></code>) that returns the bank index (ID) of a specific argument of the kernel. This ID is used as the last argument of <code class="docutils literal notranslate"><span class="pre">xclAllocBO</span></code> (in C++ with <code class="docutils literal notranslate"><span class="pre">xrt::bo</span></code> constructor) API to create the buffer on the same memory bank.</p>
<p>Let us review the example below where the buffer is allocated for the kernel’s first (argument index 0) by using this API</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>39
40</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="n">xrtMemoryGroup</span> <span class="n">idx_0</span> <span class="o">=</span> <span class="n">xrtKernelArgGroupId</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// bank index of 0th argument</span>
     <span class="n">xrtBufferHandle</span> <span class="n">a</span> <span class="o">=</span> <span class="n">xrtBOAlloc</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">data_size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span> <span class="n">XRT_BO_FLAGS_NONE</span><span class="p">,</span> <span class="n">idx_0</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>15</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="k">auto</span> <span class="n">input_buffer</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">bo</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">buffer_size_in_bytes</span><span class="p">,</span> <span class="n">kernel</span><span class="p">.</span><span class="n">group_id</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</td></tr></table></div>
<p>The API fails if the kernel bank index is ambiguous. For example, the kernel has multiple CU with different connectivity for that argument. In those cases, it is required to create a kernel object/handle with specific a CU (or group of CUs with identical connectivity).</p>
</div>
<div class="section" id="reading-and-write-cu-mapped-registers">
<h3>Reading and write CU mapped registers<a class="headerlink" href="#reading-and-write-cu-mapped-registers" title="Permalink to this headline">¶</a></h3>
<p>To read and write from the AXI-Lite register space corresponding to a CU, the CU must be opened in exclusive mode (in shared mode, multiple processes can access the CU’s address space, hence it is unsafe if they are trying to access/change registers at the same time leading to a potential race behavior). The required APIs for kernel register read and write are</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrtKernelReadRegister</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::kernel::read_register</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrtKernelWriteRegiste</span></code> (C++: member function <code class="docutils literal notranslate"><span class="pre">xrt::kernel::write_register</span></code>)</p></li>
</ul>
</div></blockquote>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="kt">int</span> <span class="n">read_data</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">write_data</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

     <span class="n">xrtKernelHandle</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">xrtPLKernelOpenExclusive</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;foo:{foo_1}&quot;</span><span class="p">);</span>

     <span class="n">xrtKernelReadRegister</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="n">READ_OFFSET</span><span class="p">,</span><span class="o">&amp;</span><span class="n">read_data</span><span class="p">);</span>
     <span class="n">xrtKernelWriteRegister</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span><span class="n">WRITE_OFFSET</span><span class="p">,</span><span class="n">write_data</span><span class="p">);</span>

     <span class="n">xrtKernelClose</span><span class="p">(</span><span class="n">kernel</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>In the above code block</p>
<blockquote>
<div><ul class="simple">
<li><p>The CU named “foo_1” (name syntax: “kernel_name:{cu_name}”) is opened exclusively.</p></li>
<li><p>The Register Read/Write operation is performed.</p></li>
<li><p>Closed the kernel</p></li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ API example</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="kt">int</span> <span class="n">read_data</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">write_data</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>

     <span class="k">auto</span> <span class="n">krnl</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;foo:{foo_1}&quot;</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

     <span class="n">read_data</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">.</span><span class="n">read_register</span><span class="p">(</span><span class="n">READ_OFFSET</span><span class="p">);</span>
     <span class="n">kernel</span><span class="p">.</span><span class="n">write_register</span><span class="p">(</span><span class="n">WRITE_OFFSET</span><span class="p">,</span><span class="n">write_data</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="section" id="obtaining-the-argument-offset">
<h4>Obtaining the argument offset<a class="headerlink" href="#obtaining-the-argument-offset" title="Permalink to this headline">¶</a></h4>
<p>The register read/write access APIs use the register offset as shown in the above examples. The user can get the register offset of a corresponding kernel argument from the <code class="docutils literal notranslate"><span class="pre">v++</span></code> generated <code class="docutils literal notranslate"><span class="pre">.xclbin.info</span></code> file and use with the register read/write APIs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>--------------------------
Instance:        foo_1
Base Address: 0x1800000

Argument:          a
Register Offset:   0x10
</pre></div>
</div>
<p>However, XRT also provides APIs to obtain the register offset for CU arguments. In the below example C API <code class="docutils literal notranslate"><span class="pre">xrtKernelArgOffset</span></code> is used to obtain offset of third argument of the CU <code class="docutils literal notranslate"><span class="pre">foo:foo_1</span></code>.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="c1">// Assume foo has 3 arguments, a,b,c (arg 0, arg 1 and arg 2 respectively)</span>

     <span class="n">xrtKernelHandle</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">xrtPLKernelOpenExclusive</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="s">&quot;foo:{foo_1}&quot;</span><span class="p">);</span>
     <span class="kt">uint32_t</span> <span class="n">arg_c_offset</span> <span class="o">=</span> <span class="n">xrtKernelArgOffset</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p><strong>C++</strong>: The equivalent C++ API example</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="c1">// Assume foo has 3 arguments, a,b,c (arg 0, arg 1 and arg 2 respectively)</span>

     <span class="k">auto</span> <span class="n">krnl</span> <span class="o">=</span> <span class="n">xrt</span><span class="o">::</span><span class="n">kernel</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;foo:{foo_1}&quot;</span><span class="p">,</span> <span class="n">xclbin_uuid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
     <span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">krnl</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="executing-the-kernel">
<h3>Executing the kernel<a class="headerlink" href="#executing-the-kernel" title="Permalink to this headline">¶</a></h3>
<p>Execution of the kernel is associated with a <strong>Run</strong> handle (or object). The kernel can be executed by the API <code class="docutils literal notranslate"><span class="pre">xrtKernelRun</span></code> (in C++ overloaded operator <code class="docutils literal notranslate"><span class="pre">xrt::kernel::operator()</span></code>) that takes all the kernel arguments in order. The kernel execution API returns a run handle (or object) corresponding to the execution.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="c1">// 1st kernel execution</span>
     <span class="n">xrtRunHandle</span> <span class="n">run</span> <span class="o">=</span> <span class="n">xrtKernelRun</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">buf_a</span><span class="p">,</span> <span class="n">buf_b</span><span class="p">,</span>  <span class="n">scalar_1</span><span class="p">);</span>
     <span class="n">xrtRunWait</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>

     <span class="c1">// 2nd kernel execution with just changing 3rd argument</span>
     <span class="n">xrtRunSetArg</span><span class="p">(</span><span class="n">run</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">scalar_2</span><span class="p">);</span> <span class="c1">// Arguments are specified starting from 0</span>
     <span class="n">xrtRunStart</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>
     <span class="n">xrtRunWait</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>

     <span class="c1">// Close the run handle</span>
     <span class="n">xrtRunClose</span><span class="p">(</span><span class="n">run</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Note the following APIs regarding  the above example</p>
<blockquote>
<div><ul>
<li><p>The kernel is executed by <code class="docutils literal notranslate"><span class="pre">xrtKernelRun</span></code> API by specifying all its arguments to obtain a Run handle</p></li>
<li><p>The API <code class="docutils literal notranslate"><span class="pre">xrtKernelRun</span></code> is non-blocking. It returns as soon as it submits the job without waiting for the kernel’s actual execution start.</p></li>
<li><p>The host code uses <code class="docutils literal notranslate"><span class="pre">xrtRunWait</span></code> API to block the current thread and wait till the kernel execution is finished.</p></li>
<li><p>After a run is finished, the same run handle can be reused to execute the kernel multiple times if desired.</p>
<blockquote>
<div><ul class="simple">
<li><p>API <code class="docutils literal notranslate"><span class="pre">xrtRunSetArg</span></code> is used to set one or more arguments, in the example above only the last (3rd) argument is changed before the second execution</p></li>
<li><p>API <code class="docutils literal notranslate"><span class="pre">xrtRunStart</span></code> is used to execute the kernel using the run handle.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>API <code class="docutils literal notranslate"><span class="pre">xrtRunClose</span></code> is used to close the Run handle.</p></li>
</ul>
</div></blockquote>
<p><strong>C++</strong>: The equivalent C++ code</p>
<p>In C++ the <code class="docutils literal notranslate"><span class="pre">xrt::kernel</span></code> class provides <strong>overloaded operator ()</strong> to execute the kernel with a comma-separated list of arguments.</p>
<div class="highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>50
51
52
53
54
55
56
57</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="c1">// 1st kernel execution</span>
     <span class="k">auto</span> <span class="n">run</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">buf_a</span><span class="p">,</span> <span class="n">buf_b</span><span class="p">,</span> <span class="n">scalar_1</span><span class="p">);</span>
     <span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>

     <span class="c1">// 2nd kernel execution with just changing 3rd argument</span>
     <span class="n">run</span><span class="p">.</span><span class="n">set_arg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">scalar_2</span><span class="p">);</span> <span class="c1">// Arguments are specified starting from 0</span>
     <span class="n">run</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
     <span class="n">run</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p>The above c++ code block is demonstrating</p>
<blockquote>
<div><ul class="simple">
<li><p>The kernel execution using the <code class="docutils literal notranslate"><span class="pre">xrt::kernel()</span></code> operator with the list of arguments that returns a xrt::run object. This is an asynchronous API and returns after submitting the task.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::wait</span></code> is used to block the current thread until the current execution is finished.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg</span></code> is used to set one or more kernel argument(s) before the next execution. In the example above, only the last (3rd) argument is changed.</p></li>
<li><p>The member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start</span></code> is used to start the next kernel execution with new argument(s).</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="other-kernel-execution-related-apis">
<h3>Other kernel execution related APIs<a class="headerlink" href="#other-kernel-execution-related-apis" title="Permalink to this headline">¶</a></h3>
<p>The Run handle/object supports few other use-cases.</p>
<p><strong>Obtaining the run handle/object before execution</strong>: In the above example we have seen a run handle/object is obtained when the kernel is executed (kernel execution returns a run handle/object). However, a run handle can be obtained even before the kernel execution. The flow is as below</p>
<blockquote>
<div><ul class="simple">
<li><p>Open a Run handle (or object) by API <code class="docutils literal notranslate"><span class="pre">xrtRunOpen</span></code> (in C++ <code class="docutils literal notranslate"><span class="pre">xrt::run</span></code> constructor with a kernel argument). There is no kernel execution associated with this run handle/object yet</p></li>
<li><p>Set the kernel arguments associated for the next execution by <code class="docutils literal notranslate"><span class="pre">xrtRunSetArg</span></code> (in C++ member function <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg</span></code>).</p></li>
<li><p>Execute the kernel by <code class="docutils literal notranslate"><span class="pre">xrtRunStart</span></code> (in C++ member function <code class="docutils literal notranslate"><span class="pre">xrt::run::start</span></code>).</p></li>
<li><p>Wait for the execution finish by <code class="docutils literal notranslate"><span class="pre">xrtRunWait</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::run::wait</span></code>).</p></li>
</ul>
</div></blockquote>
<p><strong>Timeout while wait for kernel finish</strong>: The API <code class="docutils literal notranslate"><span class="pre">xrtRunWait</span></code> blocks the current thread until the kernel execution finishes. However, a timeout supported API <code class="docutils literal notranslate"><span class="pre">xrtRunWaitFor</span></code> is also provided . The timeout number can be specified using a millisecond unit.</p>
<p>In C++, the timeout facility can be used by the same member function that takes a <code class="docutils literal notranslate"><span class="pre">std::chrono::milliseconds</span></code> to specify the timeout.</p>
<p><strong>Asynchronous update of the kernel arguments</strong>: The API <code class="docutils literal notranslate"><span class="pre">xrtRunSetArg</span></code> (C++: <code class="docutils literal notranslate"><span class="pre">xrt::run::set_arg</span></code>) is synchronous to the kernel execution. This API can only be used when kernel is in the IDLE state and before the start of the next execution. An asynchronous version of this API (only for edge platform) <code class="docutils literal notranslate"><span class="pre">xrtRunUpdateArg</span></code> (in C++ member function <code class="docutils literal notranslate"><span class="pre">xrt::run::update_arg</span></code>) is provided to change the kernel arguments asynchronous to the kernel execution.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>

        </div>
      </div>
	  
	  
	  <!-- Sphinx Page Footer block -->
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="xrt_native.main.html" class="btn btn-neutral float-right" title="XRT Native Library C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="opencl_extension.html" class="btn btn-neutral float-left" title="Xilinx OpenCL extension" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo" class="copyright">
    <p class="footerinfo">
      <span class="lastupdated">
        Last updated on October 21, 2020.
      </span>

    </p>
  </div>	  
      </div>
    </section>


  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

   <script type="text/javascript">
    jQuery(function() { Search.loadIndex("searchindex.js"); });
  </script>

  <script type="text/javascript" id="searchindexloader"></script>     	    
	    
	    
  
  
    
  
  

  
  <!--  Xilinx template footer block -->
							</div>
						</div>
					</div>
				</div>
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="footer parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
								<noindex>
									<footer>
										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">
													<div class="row">
														<div class="footerSocial parbase">
															<div class="col-md-push-6 col-lg-push-6 col-md-6 col-lg-6">
																<ul class="list-inline pull-right social-menu">
																	<li>
																		<a href="https://www.linkedin.com/company/xilinx">
																		<span class="linkedin icon"></span>
																		<span class="sr-only">Connect on LinkedIn</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.twitter.com/XilinxInc">
																		<span class="twitter icon"></span>
																		<span class="sr-only">Follow us on Twitter</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.facebook.com/XilinxInc">
																		<span class="facebook icon"></span>
																		<span class="sr-only">Connect on Facebook</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.youtube.com/XilinxInc">
																		<span class="youtube icon"></span>
																		<span class="sr-only">Watch us on YouTube</span>
																		</a>
																	</li>
																	<li>
																		<a href="https://www.xilinx.com/registration/subscriber-signup.html">
																		<span class="newsletter icon"></span>
																		<span class="sr-only">Subscribe to Newsletter</span>
																		</a>
																	</li>
																</ul>
															</div>
														</div>
														<div class="col-md-pull-6 col-lg-pull-6 col-md-6 col-lg-6">
															<span class="copyright">
                                  
                                  &copy; 2017-2020, Xilinx, Inc.
                              </span>
															<ul class="list-inline sub-menu">
																<li>
																	<a href="https://www.xilinx.com/about/privacy-policy.html">Privacy</a>
																</li>
																<li>
																	<a href="https://www.xilinx.com/about/legal.html">Legal</a>
																</li>
																<li>
																	<a href="https://www.xilinx.com/about/contact.html">Contact</a>
																</li>
															</ul>
														</div>
													</div>
												</div>
											</div>
										</div>
									</footer>
								</noindex>
							</div>
						</div>
					</div>
				</div>
				<div class="quicklinks parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<noindex>
						<span class="quickLinks">
							<ul>
								<li>
									<a href="#top" class="btn backToTop">
									<span class="fas fa-angle-up" aria-hidden="true"></span>
									</a>
								</li>
							</ul>
						</span>
					</noindex>
				</div>
			</div>
		</div>
		<script>window.CQ = window.CQ || {}</script>
		<script src="https://static.cloud.coveo.com/searchui/v2.4382/js/CoveoJsSearch.Lazy.min.js"></script>
		<script>
			var underscoreSetup = function () {
			  _.templateSettings.interpolate = /\{\{=([^-][\S\s]+?)\}\}/g;
			  _.templateSettings.evaluate = /\{\{([^-=][\S\s]+?)\}\}/g;
			  _.templateSettings.escape = /\{\{-([^=][\S\s]+?)\}\}/g;
			}
			
			underscoreSetup();
		</script>
	</body>
</html>