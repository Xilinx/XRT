/*
 * Copyright (C) 2020 Xilinx, Inc. All rights reserved.
 *
 * Authors: David Zhang <davidzha@xilinx.com>
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

#include "../xocl_drv.h"

/* CLOCK_MAX_NUM_CLOCKS should be a concept from XCLBIN_ in the future */
#define	CLOCK_MAX_NUM_CLOCKS		4
#define	OCL_CLKWIZ_STATUS_OFFSET	0x4
#define	OCL_CLKWIZ_STATUS_MASK		0xffff
#define	OCL_CLKWIZ_STATUS_MEASURE_START	0x1
#define	OCL_CLKWIZ_STATUS_MEASURE_DONE	0x2
#define	OCL_CLKWIZ_CONFIG_OFFSET(n)	(0x200 + 4 * (n))
#define	OCL_CLK_FREQ_COUNTER_OFFSET	0x8
#define	OCL_CLK_FREQ_V5_COUNTER_OFFSET	0x10
#define	OCL_CLK_FREQ_V5_CLK0_ENABLED	0x10000
#define	CLOCK_DEFAULT_EXPIRE_SECS	1

#define	CLK_MAX_VALUE		6400
#define	CLK_SHUTDOWN_BIT	0x1
#define	DEBUG_CLK_SHUTDOWN_BIT	0x2
#define	VALID_CLKSHUTDOWN_BITS	(CLK_SHUTDOWN_BIT|DEBUG_CLK_SHUTDOWN_BIT)

#define	CLOCK_ERR(clock, fmt, arg...)	\
	xocl_err(&(clock)->clock_pdev->dev, fmt "\n", ##arg)
#define	CLOCK_WARN(clock, fmt, arg...)	\
	xocl_warn(&(clock)->clock_pdev->dev, fmt "\n", ##arg)
#define	CLOCK_INFO(clock, fmt, arg...)	\
	xocl_info(&(clock)->clock_pdev->dev, fmt "\n", ##arg)
#define	CLOCK_DBG(clock, fmt, arg...)	\
	xocl_dbg(&(clock)->clock_pdev->dev, fmt "\n", ##arg)

/* spec definition of ucs_control_status channel1 */
struct ucs_control_status_ch1 {
	unsigned int shutdown_clocks_latched:1;
	unsigned int reserved1:15;
	unsigned int clock_throttling_average:14;
	unsigned int reserved2:2;
};

struct xocl_iores_map clock_res_map[] = {
	{ RESNAME_CLKWIZKERNEL1, CLOCK_IORES_CLKWIZKERNEL1 },
	{ RESNAME_CLKWIZKERNEL2, CLOCK_IORES_CLKWIZKERNEL2 },
	{ RESNAME_CLKWIZKERNEL3, CLOCK_IORES_CLKWIZKERNEL3 },
	{ RESNAME_CLKFREQ_K1_K2, CLOCK_IORES_CLKFREQ_K1_K2},
	{ RESNAME_CLKFREQ_HBM, CLOCK_IORES_CLKFREQ_HBM },
	{ RESNAME_CLKFREQ_K1, CLOCK_IORES_CLKFREQ_K1},
	{ RESNAME_CLKFREQ_K2, CLOCK_IORES_CLKFREQ_K2},
	{ RESNAME_CLKSHUTDOWN, CLOCK_IORES_CLKSHUTDOWN },
	{ RESNAME_UCS_CONTROL_STATUS, CLOCK_IORES_UCS_CONTROL_STATUS},
};

struct clock {
	struct platform_device  *clock_pdev;
	void __iomem 		*clock_base_address[CLOCK_IORES_MAX]; 
	struct mutex 		clock_lock;

	void __iomem		*clock_ucs_control_status;
	/* Below are legacy iores fields, keep unchanged until necessary */
	void __iomem		*clock_bases[CLOCK_MAX_NUM_CLOCKS];
	unsigned short		clock_ocl_frequency[CLOCK_MAX_NUM_CLOCKS];
	struct clock_freq_topology *clock_freq_topology_p;
	unsigned long		clock_freq_topology_length;
	void __iomem		*clock_freq_counter;
	void __iomem		*clock_freq_counters[CLOCK_MAX_NUM_CLOCKS];
};

static inline void __iomem *
clock_iores_get_base(struct clock *clock, int id)
{
	return clock->clock_base_address[id];
}

static inline u32 reg_rd(void __iomem *reg)
{
	if (!reg)
		return -1;

	return XOCL_READ_REG32(reg);
}

static inline void reg_wr(void __iomem *reg, u32 val)
{
	if (!reg)
		return;

	XOCL_WRITE_REG32(val, reg);
}

/*
 * Precomputed table with config0 and config2 register values together with
 * target frequency. The steps are approximately 5 MHz apart. Table is
 * generated by wiz.pl.
 */
const static struct xclmgmt_ocl_clockwiz {
	/* target frequency */
	unsigned short ocl;
	/* config0 register */
	unsigned long config0;
	/* config2 register */
	unsigned config2;
} frequency_table[] = {
	{/*1275.000*/   10.000, 	0x02EE0C01,     0x0001F47F},
	{/*1575.000*/   15.000, 	0x02EE0F01,     0x00000069},
	{/*1600.000*/   20.000, 	0x00001001,     0x00000050},
	{/*1600.000*/   25.000, 	0x00001001,     0x00000040},
	{/*1575.000*/   30.000, 	0x02EE0F01,     0x0001F434},
	{/*1575.000*/   35.000, 	0x02EE0F01,     0x0000002D},
	{/*1600.000*/   40.000, 	0x00001001,     0x00000028},
	{/*1575.000*/   45.000, 	0x02EE0F01,     0x00000023},
	{/*1600.000*/   50.000, 	0x00001001,     0x00000020},
	{/*1512.500*/   55.000, 	0x007D0F01,     0x0001F41B},
	{/*1575.000*/   60.000, 	0x02EE0F01,     0x0000FA1A},
	{/*1462.500*/   65.000, 	0x02710E01,     0x0001F416},
	{/*1575.000*/   70.000, 	0x02EE0F01,     0x0001F416},
	{/*1575.000*/   75.000, 	0x02EE0F01,     0x00000015},
	{/*1600.000*/   80.000, 	0x00001001,     0x00000014},
	{/*1487.500*/   85.000, 	0x036B0E01,     0x0001F411},
	{/*1575.000*/   90.000, 	0x02EE0F01,     0x0001F411},
	{/*1425.000*/   95.000, 	0x00FA0E01,     0x0000000F},
	{/*1600.000*/   100.000,        0x00001001,     0x00000010},
	{/*1575.000*/   105.000,        0x02EE0F01,     0x0000000F},
	{/*1512.500*/   110.000,        0x007D0F01,     0x0002EE0D},
	{/*1437.500*/   115.000,        0x01770E01,     0x0001F40C},
	{/*1575.000*/   120.000,        0x02EE0F01,     0x00007D0D},
	{/*1562.500*/   125.000,        0x02710F01,     0x0001F40C},
	{/*1462.500*/   130.000,        0x02710E01,     0x0000FA0B},
	{/*1350.000*/   135.000,        0x01F40D01,     0x0000000A},
	{/*1575.000*/   140.000,        0x02EE0F01,     0x0000FA0B},
	{/*1450.000*/   145.000,        0x01F40E01,     0x0000000A},
	{/*1575.000*/   150.000,        0x02EE0F01,     0x0001F40A},
	{/*1550.000*/   155.000,        0x01F40F01,     0x0000000A},
	{/*1600.000*/   160.000,        0x00001001,     0x0000000A},
	{/*1237.500*/   165.000,        0x01770C01,     0x0001F407},
	{/*1487.500*/   170.000,        0x036B0E01,     0x0002EE08},
	{/*1575.000*/   175.000,        0x02EE0F01,     0x00000009},
	{/*1575.000*/   180.000,        0x02EE0F01,     0x0002EE08},
	{/*1387.500*/   185.000,        0x036B0D01,     0x0001F407},
	{/*1425.000*/   190.000,        0x00FA0E01,     0x0001F407},
	{/*1462.500*/   195.000,        0x02710E01,     0x0001F407},
	{/*1600.000*/   200.000,        0x00001001,     0x00000008},
	{/*1537.500*/   205.000,        0x01770F01,     0x0001F407},
	{/*1575.000*/   210.000,        0x02EE0F01,     0x0001F407},
	{/*1075.000*/   215.000,        0x02EE0A01,     0x00000005},
	{/*1512.500*/   220.000,        0x007D0F01,     0x00036B06},
	{/*1575.000*/   225.000,        0x02EE0F01,     0x00000007},
	{/*1437.500*/   230.000,        0x01770E01,     0x0000FA06},
	{/*1175.000*/   235.000,        0x02EE0B01,     0x00000005},
	{/*1500.000*/   240.000,        0x00000F01,     0x0000FA06},
	{/*1225.000*/   245.000,        0x00FA0C01,     0x00000005},
	{/*1562.500*/   250.000,        0x02710F01,     0x0000FA06},
	{/*1275.000*/   255.000,        0x02EE0C01,     0x00000005},
	{/*1462.500*/   260.000,        0x02710E01,     0x00027105},
	{/*1325.000*/   265.000,        0x00FA0D01,     0x00000005},
	{/*1350.000*/   270.000,        0x01F40D01,     0x00000005},
	{/*1512.500*/   275.000,        0x007D0F01,     0x0001F405},
	{/*1575.000*/   280.000,        0x02EE0F01,     0x00027105},
	{/*1425.000*/   285.000,        0x00FA0E01,     0x00000005},
	{/*1450.000*/   290.000,        0x01F40E01,     0x00000005},
	{/*1475.000*/   295.000,        0x02EE0E01,     0x00000005},
	{/*1575.000*/   300.000,        0x02EE0F01,     0x0000FA05},
	{/*1525.000*/   305.000,        0x00FA0F01,     0x00000005},
	{/*1550.000*/   310.000,        0x01F40F01,     0x00000005},
	{/*1575.000*/   315.000,        0x02EE0F01,     0x00000005},
	{/*1600.000*/   320.000,        0x00001001,     0x00000005},
	{/*1462.500*/   325.000,        0x02710E01,     0x0001F404},
	{/*1237.500*/   330.000,        0x01770C01,     0x0002EE03},
	{/*837.500*/    335.000,        0x01770801,     0x0001F402},
	{/*1487.500*/   340.000,        0x036B0E01,     0x00017704},
	{/*862.500*/    345.000,        0x02710801,     0x0001F402},
	{/*1575.000*/   350.000,        0x02EE0F01,     0x0001F404},
	{/*887.500*/    355.000,        0x036B0801,     0x0001F402},
	{/*1575.000*/   360.000,        0x02EE0F01,     0x00017704},
	{/*912.500*/    365.000,        0x007D0901,     0x0001F402},
	{/*1387.500*/   370.000,        0x036B0D01,     0x0002EE03},
	{/*1500.000*/   375.000,        0x00000F01,     0x00000004},
	{/*1425.000*/   380.000,        0x00FA0E01,     0x0002EE03},
	{/*962.500*/    385.000,        0x02710901,     0x0001F402},
	{/*1462.500*/   390.000,        0x02710E01,     0x0002EE03},
	{/*987.500*/    395.000,        0x036B0901,     0x0001F402},
	{/*1600.000*/   400.000,        0x00001001,     0x00000004},
	{/*1012.500*/   405.000,        0x007D0A01,     0x0001F402},
	{/*1537.500*/   410.000,        0x01770F01,     0x0002EE03},
	{/*1037.500*/   415.000,        0x01770A01,     0x0001F402},
	{/*1575.000*/   420.000,        0x02EE0F01,     0x0002EE03},
	{/*1487.500*/   425.000,        0x036B0E01,     0x0001F403},
	{/*1075.000*/   430.000,        0x02EE0A01,     0x0001F402},
	{/*1087.500*/   435.000,        0x036B0A01,     0x0001F402},
	{/*1375.000*/   440.000,        0x02EE0D01,     0x00007D03},
	{/*1112.500*/   445.000,        0x007D0B01,     0x0001F402},
	{/*1575.000*/   450.000,        0x02EE0F01,     0x0001F403},
	{/*1137.500*/   455.000,        0x01770B01,     0x0001F402},
	{/*1437.500*/   460.000,        0x01770E01,     0x00007D03},
	{/*1162.500*/   465.000,        0x02710B01,     0x0001F402},
	{/*1175.000*/   470.000,        0x02EE0B01,     0x0001F402},
	{/*1425.000*/   475.000,        0x00FA0E01,     0x00000003},
	{/*1500.000*/   480.000,        0x00000F01,     0x00007D03},
	{/*1212.500*/   485.000,        0x007D0C01,     0x0001F402},
	{/*1225.000*/   490.000,        0x00FA0C01,     0x0001F402},
	{/*1237.500*/   495.000,        0x01770C01,     0x0001F402},
	{/*1562.500*/   500.000,        0x02710F01,     0x00007D03},
	{/*1262.500*/   505.000,        0x02710C01,     0x0001F402},
	{/*1275.000*/   510.000,        0x02EE0C01,     0x0001F402},
	{/*1287.500*/   515.000,        0x036B0C01,     0x0001F402},
	{/*1300.000*/   520.000,        0x00000D01,     0x0001F402},
	{/*1575.000*/   525.000,        0x02EE0F01,     0x00000003},
	{/*1325.000*/   530.000,        0x00FA0D01,     0x0001F402},
	{/*1337.500*/   535.000,        0x01770D01,     0x0001F402},
	{/*1350.000*/   540.000,        0x01F40D01,     0x0001F402},
	{/*1362.500*/   545.000,        0x02710D01,     0x0001F402},
	{/*1512.500*/   550.000,        0x007D0F01,     0x0002EE02},
	{/*1387.500*/   555.000,        0x036B0D01,     0x0001F402},
	{/*1400.000*/   560.000,        0x00000E01,     0x0001F402},
	{/*1412.500*/   565.000,        0x007D0E01,     0x0001F402},
	{/*1425.000*/   570.000,        0x00FA0E01,     0x0001F402},
	{/*1437.500*/   575.000,        0x01770E01,     0x0001F402},
	{/*1450.000*/   580.000,        0x01F40E01,     0x0001F402},
	{/*1462.500*/   585.000,        0x02710E01,     0x0001F402},
	{/*1475.000*/   590.000,        0x02EE0E01,     0x0001F402},
	{/*1487.500*/   595.000,        0x036B0E01,     0x0001F402},
	{/*1575.000*/   600.000,        0x02EE0F01,     0x00027102},
	{/*1512.500*/   605.000,        0x007D0F01,     0x0001F402},
	{/*1525.000*/   610.000,        0x00FA0F01,     0x0001F402},
	{/*1537.500*/   615.000,        0x01770F01,     0x0001F402},
	{/*1550.000*/   620.000,        0x01F40F01,     0x0001F402},
	{/*1562.500*/   625.000,        0x02710F01,     0x0001F402},
	{/*1575.000*/   630.000,        0x02EE0F01,     0x0001F402},
	{/*1587.500*/   635.000,        0x036B0F01,     0x0001F402},
	{/*1600.000*/   640.000,        0x00001001,     0x0001F402},
	{/*1290.000*/   645.000,        0x01F44005,     0x00000002},
	{/*1462.500*/   650.000,        0x02710E01,     0x0000FA02}
};

static unsigned find_matching_freq_config(unsigned freq)
{
	unsigned start = 0;
	unsigned end = ARRAY_SIZE(frequency_table) - 1;
	unsigned idx = ARRAY_SIZE(frequency_table) - 1;

	if (freq < frequency_table[0].ocl)
		return 0;

	if (freq > frequency_table[ARRAY_SIZE(frequency_table) - 1].ocl)
		return ARRAY_SIZE(frequency_table) - 1;

	while (start < end) {
		if (freq == frequency_table[idx].ocl)
			break;
		if (freq < frequency_table[idx].ocl)
			end = idx;
		else
			start = idx + 1;
		idx = start + (end - start) / 2;
	}
	if (freq < frequency_table[idx].ocl)
		idx--;

	return idx;
}

static unsigned find_matching_freq(unsigned freq)
{
	int idx = find_matching_freq_config(freq);

	return frequency_table[idx].ocl;
}

static unsigned int clock_get_freq_counter_khz_impl(struct clock *clock, int idx)
{
	u32 freq = 0, status;
	int times = 10;

	BUG_ON(idx > CLOCK_MAX_NUM_CLOCKS);
	BUG_ON(!mutex_is_locked(&clock->clock_lock));

	if (clock->clock_freq_counter && idx < 2) {
		reg_wr(clock->clock_freq_counter,
			OCL_CLKWIZ_STATUS_MEASURE_START);
		while (times != 0) {
			status = reg_rd(clock->clock_freq_counter);
			if ((status & OCL_CLKWIZ_STATUS_MASK) ==
				OCL_CLKWIZ_STATUS_MEASURE_DONE)
				break;
			mdelay(1);
			times--;
		};
		if ((status & OCL_CLKWIZ_STATUS_MASK) ==
			OCL_CLKWIZ_STATUS_MEASURE_DONE)
			freq = reg_rd(clock->clock_freq_counter + OCL_CLK_FREQ_COUNTER_OFFSET + idx*sizeof(u32));
		return freq;
	}

	if (clock->clock_freq_counters[idx]) {
		reg_wr(clock->clock_freq_counters[idx],
			OCL_CLKWIZ_STATUS_MEASURE_START);
		while (times != 0) {
			status =
			    reg_rd(clock->clock_freq_counters[idx]);
			if ((status & OCL_CLKWIZ_STATUS_MASK) ==
				OCL_CLKWIZ_STATUS_MEASURE_DONE)
				break;
			mdelay(1);
			times--;
		};
		if ((status & OCL_CLKWIZ_STATUS_MASK) ==
			OCL_CLKWIZ_STATUS_MEASURE_DONE) {
			freq = (status & OCL_CLK_FREQ_V5_CLK0_ENABLED) ?
				reg_rd(clock->clock_freq_counters[idx] + OCL_CLK_FREQ_V5_COUNTER_OFFSET) :
				reg_rd(clock->clock_freq_counters[idx] + OCL_CLK_FREQ_COUNTER_OFFSET);
		}
	}
	return freq;
}

static unsigned short clock_get_freq_impl(struct clock *clock, int idx)
{
#define XCL_INPUT_FREQ 100
	const u64 input = XCL_INPUT_FREQ;
	u32 val;
	u32 mul0, div0;
	u32 mul_frac0 = 0;
	u32 div1;
	u32 div_frac1 = 0;
	u64 freq = 0;
	char *base = NULL;

	BUG_ON(!mutex_is_locked(&clock->clock_lock));

	base = clock->clock_bases[idx];
	if (!base)
		return 0;
	val = reg_rd(base + OCL_CLKWIZ_STATUS_OFFSET);
	if ((val & 1) == 0)
		return 0;

	val = reg_rd(base + OCL_CLKWIZ_CONFIG_OFFSET(0));

	div0 = val & 0xff;
	mul0 = (val & 0xff00) >> 8;
	if (val & BIT(26)) {
		mul_frac0 = val >> 16;
		mul_frac0 &= 0x3ff;
	}

	/*
	 * Multiply both numerator (mul0) and the denominator (div0) with 1000
	 * to account for fractional portion of multiplier
	 */
	mul0 *= 1000;
	mul0 += mul_frac0;
	div0 *= 1000;

	val = reg_rd(base + OCL_CLKWIZ_CONFIG_OFFSET(2));

	div1 = val & 0xff;
	if (val & BIT(18)) {
		div_frac1 = val >> 8;
		div_frac1 &= 0x3ff;
	}

	/*
	 * Multiply both numerator (mul0) and the denominator (div1) with 1000 to
	 * account for fractional portion of divider
	 */

	div1 *= 1000;
	div1 += div_frac1;
	div0 *= div1;
	mul0 *= 1000;
	if (div0 == 0) {
		CLOCK_ERR(clock, "clockwiz 0 divider");
		return 0;
	}
	freq = (input * mul0) / div0;
	return freq;
}

/*
 * Based on Clocking Wizard v5.1, section Dynamic Reconfiguration
 * through AXI4-Lite
 * Note: this is being protected by write_lock which is atomic context,
 *       we should only use n[m]delay instead of n[m]sleep.
 *       based on Linux doc of timers, mdelay may not be exactly accurate
 *       on non-PC devices.
 */
static int clock_ocl_freqscaling(struct clock *clock, bool force)
{
	unsigned curr_freq;
	u32 config;
	int i;
	int j = 0;
	u32 val = 0;
	unsigned idx = 0;
	long err = 0;

	BUG_ON(!mutex_is_locked(&clock->clock_lock));

	for (i = 0; i < CLOCK_MAX_NUM_CLOCKS; ++i) {
		/* A value of zero means skip scaling for this clock index */
		if (!clock->clock_ocl_frequency[i])
			continue;
		/* skip if the io does not exist */
		if (!clock->clock_bases[i])
			continue;

		idx = find_matching_freq_config(clock->clock_ocl_frequency[i]);
		curr_freq = clock_get_freq_impl(clock, i);
		CLOCK_INFO(clock, "Clock %d, Current %d Mhz, New %d Mhz ",
				i, curr_freq, clock->clock_ocl_frequency[i]);

		/*
		 * If current frequency is in the same step as the
		 * requested frequency then nothing to do.
		 */
		if (!force && (find_matching_freq_config(curr_freq) == idx))
			continue;

		val = reg_rd(clock->clock_bases[i] +
			OCL_CLKWIZ_STATUS_OFFSET);
		if (val != 1) {
			CLOCK_ERR(clock, "clockwiz %d is busy", i);
			err = -EBUSY;
			break;
		}
		config = frequency_table[idx].config0;
		reg_wr(clock->clock_bases[i] + OCL_CLKWIZ_CONFIG_OFFSET(0),
			config);
		config = frequency_table[idx].config2;
		reg_wr(clock->clock_bases[i] + OCL_CLKWIZ_CONFIG_OFFSET(2),
			config);
		mdelay(10);
		reg_wr(clock->clock_bases[i] + OCL_CLKWIZ_CONFIG_OFFSET(23),
			0x00000007);
		mdelay(1);
		reg_wr(clock->clock_bases[i] + OCL_CLKWIZ_CONFIG_OFFSET(23),
			0x00000002);

		CLOCK_INFO(clock, "clockwiz waiting for locked signal");
		mdelay(100);
		for (j = 0; j < 100; j++) {
			val = reg_rd(clock->clock_bases[i] +
				OCL_CLKWIZ_STATUS_OFFSET);
			if (val != 1) {
				mdelay(100);
				continue;
			}
		}
		if (val != 1) {
			CLOCK_ERR(clock, "clockwiz MMCM/PLL did not lock after %d"
				"ms, restoring the original configuration",
				100 * 100);
			/* restore the original clock configuration */
			reg_wr(clock->clock_bases[i] +
				OCL_CLKWIZ_CONFIG_OFFSET(23), 0x00000004);
			mdelay(10);
			reg_wr(clock->clock_bases[i] +
				OCL_CLKWIZ_CONFIG_OFFSET(23), 0x00000000);
			err = -ETIMEDOUT;
			break;
		}
		val = reg_rd(clock->clock_bases[i] +
			OCL_CLKWIZ_CONFIG_OFFSET(0));
		CLOCK_INFO(clock, "clockwiz CONFIG(0) 0x%x", val);
		val = reg_rd(clock->clock_bases[i] +
			OCL_CLKWIZ_CONFIG_OFFSET(2));
		CLOCK_INFO(clock, "clockwiz CONFIG(2) 0x%x", val);
	}

	CLOCK_INFO(clock, "returns %ld", err);
	return err;
}

static int set_freqs(struct clock *clock, unsigned short *freqs, int num_freqs,
	struct gate_handler *gate_handle)
{
	int i;
	int err = 0;
	u32 val;

	BUG_ON(!mutex_is_locked(&clock->clock_lock));

	for (i = 0; i < min(CLOCK_MAX_NUM_CLOCKS, num_freqs); ++i) {
		if (freqs[i] == 0)
			continue;

		if (!clock->clock_bases[i])
			continue;

		val = reg_rd(clock->clock_bases[i] +
			OCL_CLKWIZ_STATUS_OFFSET);
		if ((val & 0x1) == 0) {
			CLOCK_ERR(clock, "clockwiz %d is busy", i);
			err = -EBUSY;
			goto done;
		}
	}

	memcpy(clock->clock_ocl_frequency, freqs,
		sizeof(*freqs) * min(CLOCK_MAX_NUM_CLOCKS, num_freqs));

	/*
	 * When gate_handler callback funcs are present, we freeze and free the
	 * gate. It is caller's fault if freeze and free pair has not been set
	 * appropriately.
	 * When ep_ucs_control_status_00 is present, clock is in ULP. The gate
	 * handler is smart enough to do right operations.
	 */
	if (gate_handle->gate_freeze_cb)
		gate_handle->gate_freeze_cb(gate_handle->gate_args);

	err = clock_ocl_freqscaling(clock, false);

	if (gate_handle->gate_free_cb)
		gate_handle->gate_free_cb(gate_handle->gate_args);

	/* enable kernel clocks */
	if (clock->clock_ucs_control_status) {
		CLOCK_INFO(clock, "Enable kernel clocks ucs control");
		reg_wr(clock->clock_ucs_control_status +
			XOCL_RES_OFFSET_CHANNEL2, 0x1);
	}

done:
	CLOCK_INFO(clock, "returns %d", err);
	return err;
}

static int set_and_verify_freqs(struct clock *clock, unsigned short *freqs,
	int num_freqs, struct gate_handler *gate_handle)
{
	int i;
	int err;
	u32 clock_freq_counter, request_in_khz, tolerance, lookup_freq;

	BUG_ON(!mutex_is_locked(&clock->clock_lock));

	err = set_freqs(clock, freqs, num_freqs, gate_handle);
	if (err)
		goto done;

	for (i = 0; i < min(CLOCK_MAX_NUM_CLOCKS, num_freqs); ++i) {
		if (!freqs[i])
			continue;

		lookup_freq = find_matching_freq(freqs[i]);
		clock_freq_counter = clock_get_freq_counter_khz_impl(clock, i);
		request_in_khz = lookup_freq*1000;
		tolerance = lookup_freq*50;
		if (tolerance < abs(clock_freq_counter-request_in_khz)) {
			CLOCK_ERR(clock, "Frequency is higher than tolerance value, request %u"
					"khz, actual %u khz", request_in_khz, clock_freq_counter);
			err = -EDOM;
			break;
		}
	}

done:
	return err;
}

static int clock_freq_scaling(struct platform_device *pdev, bool force)
{
	struct clock *clock = platform_get_drvdata(pdev);
	int err = 0;

	mutex_lock(&clock->clock_lock);
	err =  clock_ocl_freqscaling(clock, force);
	mutex_unlock(&clock->clock_lock);

	CLOCK_INFO(clock, "ret: %d.", err);
	return err;
}

static int clock_update_freq(struct platform_device *pdev,
	unsigned short *freqs, int num_freqs, int verify,
	struct gate_handler *gate_handle)
{
	struct clock *clock = platform_get_drvdata(pdev);
	int err = 0;

	if (gate_handle == NULL) {
		CLOCK_ERR(clock, "gate_handle must be set");
		return -EINVAL;
	}

	mutex_lock(&clock->clock_lock);
	err = verify ?
	    set_and_verify_freqs(clock, freqs, num_freqs, gate_handle) :
	    set_freqs(clock, freqs, num_freqs, gate_handle);
	mutex_unlock(&clock->clock_lock);

	CLOCK_INFO(clock, "ret: %d.", err);
	return err;
}

static int clock_get_freq_counter_khz(struct platform_device *pdev,
	unsigned int *value, int id)
{
	struct clock *clock = platform_get_drvdata(pdev);

	if (id > CLOCK_MAX_NUM_CLOCKS) {
		CLOCK_ERR(clock, "id %d cannot be greater than %d",
		    id, CLOCK_MAX_NUM_CLOCKS);
		return -EINVAL;
	}

	mutex_lock(&clock->clock_lock);
	*value = clock_get_freq_counter_khz_impl(clock, id);
	mutex_unlock(&clock->clock_lock);

	CLOCK_INFO(clock, "khz: %d", *value);
	return 0;
}

static int clock_get_freq_by_id(struct platform_device *pdev,
	unsigned int region, unsigned short *freq, int id)
{
	struct clock *clock = platform_get_drvdata(pdev);

	/* For now, only PR region 0 is supported. */
	if (region != 0) {
		CLOCK_ERR(clock, "only PR region 0 is supported");
		return -EINVAL;
	}

	if (id > CLOCK_MAX_NUM_CLOCKS) {
		CLOCK_ERR(clock, "id %d cannot be greater than %d",
		    id, CLOCK_MAX_NUM_CLOCKS);
		return -EINVAL;
	}

	mutex_lock(&clock->clock_lock);
	*freq = clock_get_freq_impl(clock, id);
	mutex_unlock(&clock->clock_lock);

	CLOCK_INFO(clock, "freq = %hu", *freq);
	return 0;
}

static int clock_get_freq(struct platform_device *pdev,
	unsigned int region, unsigned short *freqs, int num_freqs)
{
	int i;
	struct clock *clock = platform_get_drvdata(pdev);

	/* For now, only PR region 0 is supported. */
	if (region != 0) {
		CLOCK_ERR(clock, "only PR region 0 is supported");
		return -EINVAL;
	}

	mutex_lock(&clock->clock_lock);
	for (i = 0; i < min(CLOCK_MAX_NUM_CLOCKS, num_freqs); i++)
		freqs[i] = clock_get_freq_impl(clock, i);
	mutex_unlock(&clock->clock_lock);

	CLOCK_INFO(clock, "done.");
	return 0;
}

static int clock_status_check(struct platform_device *pdev, bool *latched)
{	
	struct clock *clock = platform_get_drvdata(pdev);
	void __iomem *shutdown_clk =
		clock_iores_get_base(clock, CLOCK_IORES_CLKSHUTDOWN);
	void __iomem *ucs_control_status =
		clock_iores_get_base(clock, CLOCK_IORES_UCS_CONTROL_STATUS);
	uint32_t status;
	int err = 0;

	if (shutdown_clk) {
		status = reg_rd(shutdown_clk);
		/* BIT0:latch bit, BIT1:Debug bit */
		if (!(status & (~VALID_CLKSHUTDOWN_BITS))) {
			*latched = status & CLK_SHUTDOWN_BIT;
			if (*latched) {
				CLOCK_ERR(clock, "Compute-Unit clocks have "
				    "been stopped! Power or Temp may exceed "
				    "limits, notify peer");
			}
		}
	} else if (ucs_control_status) {
		struct ucs_control_status_ch1 *ucs_status_ch1;

		/* this must be a R2.0 system */
		status = reg_rd(ucs_control_status + XOCL_RES_OFFSET_CHANNEL1);
		ucs_status_ch1 = (struct ucs_control_status_ch1 *)&status;
		if (ucs_status_ch1->shutdown_clocks_latched) {
			CLOCK_ERR(clock, "Critical temperature or power event, "
			    "ULP kernel clocks have been stopped, reload the "
			    "ULP to continue.");
			/* explicitly indicate reset should be latched */
			*latched = true;
		} else if (ucs_status_ch1->clock_throttling_average > CLK_MAX_VALUE) {
			CLOCK_ERR(clock, "ULP kernel clocks %d exceeds "
			    "expected maximum value %d.",
			    ucs_status_ch1->clock_throttling_average, CLK_MAX_VALUE);
		} else if (ucs_status_ch1->clock_throttling_average) {
			CLOCK_ERR(clock, "ULP kernel clocks throttled at %d%%.",
			    (ucs_status_ch1->clock_throttling_average /
			    (CLK_MAX_VALUE / 100)));
		}
	}

	/* do not out put status log here, this function might be called every 5s */
	return err;
}

/* there are some iores have not been defined in neither xsabin nor xclbin */
static void clock_prev_refresh_addrs(struct clock *clock)
{
	xdev_handle_t xdev = xocl_get_xdev(clock->clock_pdev);

	mutex_lock(&clock->clock_lock);

	clock->clock_freq_counter =
		xocl_iores_get_base(xdev, IORES_CLKFREQ_K1_K2);
	CLOCK_INFO(clock, "freq_k1_k2 @ %lx",
			(unsigned long)clock->clock_freq_counter);

	clock->clock_freq_counters[2] =
		xocl_iores_get_base(xdev, IORES_CLKFREQ_HBM);
	CLOCK_INFO(clock, "freq_hbm @ %lx",
			(unsigned long)clock->clock_freq_counters[2]);

	mutex_unlock(&clock->clock_lock);

	CLOCK_INFO(clock, "done.");
}

static void clock_iores_update_base(struct clock *clock,
	void __iomem **resource, int id, bool force_update)
{
	char *res_name = xocl_res_id2name(clock_res_map,
	    ARRAY_SIZE(clock_res_map), id);

	if (*resource && !force_update) {
		CLOCK_INFO(clock, "%s has been set to %lx already.",
		    res_name ? res_name : "", (unsigned long)(*resource));
		return;
	}

	*resource = clock_iores_get_base(clock, id);
	CLOCK_INFO(clock, "%s @ %lx", res_name ? res_name : "",
	    (unsigned long)(*resource));
}

/* when iores has been loaded from xsabin or xclbin */
static int clock_post_refresh_addrs(struct clock *clock)
{
	int err = 0;

	mutex_lock(&clock->clock_lock);

	clock_iores_update_base(clock,
	    &clock->clock_bases[0], CLOCK_IORES_CLKWIZKERNEL1, true);

	clock_iores_update_base(clock,
	    &clock->clock_bases[1], CLOCK_IORES_CLKWIZKERNEL2, true);

	clock_iores_update_base(clock,
	    &clock->clock_bases[2], CLOCK_IORES_CLKWIZKERNEL3, true);

	clock_iores_update_base(clock,
	    &clock->clock_freq_counter, CLOCK_IORES_CLKFREQ_K1_K2, false);

	clock_iores_update_base(clock,
	    &clock->clock_freq_counters[0], CLOCK_IORES_CLKFREQ_K1, true);

	clock_iores_update_base(clock,
	    &clock->clock_freq_counters[1], CLOCK_IORES_CLKFREQ_K2, true);

	clock_iores_update_base(clock,
	    &clock->clock_freq_counters[2], CLOCK_IORES_CLKFREQ_HBM, false);

	clock_iores_update_base(clock,
	    &clock->clock_ucs_control_status, CLOCK_IORES_UCS_CONTROL_STATUS, true);

	/*
	 * Note: we are data driven, as long as ucs_control_status is present,
	 *       operations will be performed.
	 *       With new 2RP flow, clocks are all moved to ULP.  We assume
	 *       there is not any clock left in PLP in this case.
	 */
	if (clock->clock_ucs_control_status) {
		err = clock_ocl_freqscaling(clock, true);
		msleep(10);
		reg_wr(clock->clock_ucs_control_status +
			XOCL_RES_OFFSET_CHANNEL2, 0x1);
	}

	mutex_unlock(&clock->clock_lock);

	CLOCK_INFO(clock, "ret %d", err);
	return err;
}

static ssize_t clock_freqs_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct clock *clock = platform_get_drvdata(to_platform_device(dev));
	ssize_t cnt = 0;
	int i;
	u32 freq_counter, freq, request_in_khz, tolerance;

	mutex_lock(&clock->clock_lock);
	for (i = 0; i < CLOCK_MAX_NUM_CLOCKS; i++) {
		freq = clock_get_freq_impl(clock, i);
		if (clock->clock_freq_counter || clock->clock_freq_counters[i]) {
			freq_counter = clock_get_freq_counter_khz_impl(clock, i);
			request_in_khz = freq*1000;
			tolerance = freq*50;

			if (abs(freq_counter-request_in_khz) > tolerance)
				CLOCK_INFO(clock, "Frequency mismatch, Should be %u khz, Now is %ukhz", request_in_khz, freq_counter);
			cnt += sprintf(buf + cnt, "%d\n", DIV_ROUND_CLOSEST(freq_counter, 1000));
		} else
			cnt += sprintf(buf + cnt, "%d\n", freq);
	}

	mutex_unlock(&clock->clock_lock);
	return cnt;
}
static DEVICE_ATTR_RO(clock_freqs);

static struct attribute *clock_attrs[] = {
	&dev_attr_clock_freqs.attr,
	NULL,
};

static struct attribute_group clock_attr_group = {
	.attrs = clock_attrs,
};

static struct xocl_clock_funcs clock_ops = {
	.freq_scaling = clock_freq_scaling,
	.get_freq_counter_khz = clock_get_freq_counter_khz,
	.get_freq_by_id = clock_get_freq_by_id,
	.get_freq = clock_get_freq,
	.update_freq = clock_update_freq,
	.clock_status = clock_status_check,
};

static int clock_remove(struct platform_device *pdev)
{
	struct clock *clock;

	clock = platform_get_drvdata(pdev);
	if (!clock) {
		xocl_err(&pdev->dev, "driver data is NULL");
		return -EINVAL;
	}

	sysfs_remove_group(&pdev->dev.kobj, &clock_attr_group);
	mutex_destroy(&clock->clock_lock);

	platform_set_drvdata(pdev, NULL);
	devm_kfree(&pdev->dev, clock);

	CLOCK_INFO(clock, "successfully removed Clock subdev");
	return 0;
}

static int clock_probe(struct platform_device *pdev)
{
	struct clock *clock = NULL;
	struct resource *res;
	int ret, i, id;

	clock = devm_kzalloc(&pdev->dev, sizeof(*clock), GFP_KERNEL);
	if (!clock)
		return -ENOMEM;

	platform_set_drvdata(pdev, clock);
	clock->clock_pdev = pdev;
	mutex_init(&clock->clock_lock);

	clock_prev_refresh_addrs(clock);

	for (i = 0, res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
		res;
		res = platform_get_resource(pdev, IORESOURCE_MEM, ++i)) {
		id = xocl_res_name2id(clock_res_map, ARRAY_SIZE(clock_res_map),
			res->name);
		if (id >= 0) {
			clock->clock_base_address[id] =
				ioremap_nocache(res->start,
				res->end - res->start + 1);
			if (!clock->clock_base_address[id]) {
				CLOCK_ERR(clock, "map base %pR failed", res);
				ret = -EINVAL;
				goto failed;
			} else {
				CLOCK_INFO(clock, "res[%d] %s mapped @ %lx",
				    i, res->name,
				    (unsigned long)clock->clock_base_address[id]);
			}
		}
	}
	clock_post_refresh_addrs(clock);

	ret = sysfs_create_group(&pdev->dev.kobj, &clock_attr_group);
	if (ret) {
		CLOCK_ERR(clock, "create clock attrs failed: %d", ret);
		goto failed;
	}

	CLOCK_INFO(clock, "successfully initialized Clock subdev");
	return 0;

failed:
	(void) clock_remove(pdev);
	return ret;
}

struct xocl_drv_private clock_priv = {
	.ops = &clock_ops,
};

struct platform_device_id clock_id_table[] = {
	{ XOCL_DEVNAME(XOCL_CLOCK), (kernel_ulong_t)&clock_priv },
	{ },
};

static struct platform_driver	clock_driver = {
	.probe		= clock_probe,
	.remove		= clock_remove,
	.driver		= {
		.name = XOCL_DEVNAME(XOCL_CLOCK),
	},
	.id_table = clock_id_table,
};

int __init xocl_init_clock(void)
{
	return platform_driver_register(&clock_driver);
}

void xocl_fini_clock(void)
{
	platform_driver_unregister(&clock_driver);
}
