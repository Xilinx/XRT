diff --git a/src/runtime_src/core/common/info_telemetry.cpp b/src/runtime_src/core/common/info_telemetry.cpp
index 2f05a3af0..463d01f8f 100644
--- a/src/runtime_src/core/common/info_telemetry.cpp
+++ b/src/runtime_src/core/common/info_telemetry.cpp
@@ -47,14 +47,19 @@ aie2_preemption_info(const xrt_core::device* device)
   for (const auto& kp : data) {
   boost::property_tree::ptree pt_preempt;
 
-  //add a check for not supported
-  if(static_cast<int>(kp.preemption_data.preemption_flag_set) == -1) 
-    return pt_rtos_array; //not supported
-  pt_preempt.put("slot_index", kp.preemption_data.slot_index);
-  pt_preempt.put("preemption_flag_set", kp.preemption_data.preemption_flag_set);
-  pt_preempt.put("preemption_flag_unset", kp.preemption_data.preemption_flag_unset);
-  pt_preempt.put("preemption_checkpoint_event", kp.preemption_data.preemption_checkpoint_event);
-  pt_preempt.put("preemption_frame_boundary_events", kp.preemption_data.preemption_frame_boundary_events);
+    auto populate_value = [](uint64_t value) {
+      return (value == static_cast<uint64_t>(-1) || value == UINT64_MAX) ? "N/A" : std::to_string(value);
+    };
+
+  //add check if a workload is running
+  if(static_cast<int>(kp.preemption_data.slot_index) == -1) 
+    continue;
+  pt_preempt.put("user_task", populate_value(kp.user_task));
+  pt_preempt.put("slot_index", populate_value(kp.preemption_data.slot_index));
+  pt_preempt.put("preemption_flag_set", populate_value(kp.preemption_data.preemption_flag_set));
+  pt_preempt.put("preemption_flag_unset", populate_value(kp.preemption_data.preemption_flag_unset));
+  pt_preempt.put("preemption_checkpoint_event", populate_value(kp.preemption_data.preemption_checkpoint_event));
+  pt_preempt.put("preemption_frame_boundary_events", populate_value(kp.preemption_data.preemption_frame_boundary_events));
 
   pt_rtos_array.push_back({"", pt_preempt});
   }
diff --git a/src/runtime_src/core/common/query_requests.h b/src/runtime_src/core/common/query_requests.h
index 56614736c..0be8b1e8b 100644
--- a/src/runtime_src/core/common/query_requests.h
+++ b/src/runtime_src/core/common/query_requests.h
@@ -1752,6 +1752,23 @@ struct aie_partition_info : request
 
   virtual std::any
   get(const device* device) const = 0;
+
+  static std::string
+  parse_priority_status(const uint64_t prio_status)
+  {
+    switch(prio_status) {
+      case 256: //0x100
+        return "Realtime";
+      case 384: //0x180
+        return "High";
+      case 512: //0x200
+        return "Normal";
+      case 640: //0x280
+        return "Low";
+      default:
+        throw xrt_core::system_error(EINVAL, "Invalid priority status: " + std::to_string(prio_status));
+    }
+  }
 };
 
 // Retrieves the AIE telemetry info for the device
@@ -1822,6 +1839,7 @@ struct rtos_telemetry : request
   };
 
   struct data {
+    uint64_t user_task;
     uint64_t context_starts;
     uint64_t schedules;
     uint64_t syscalls;
diff --git a/src/runtime_src/core/tools/common/reports/ReportAiePartitions.cpp b/src/runtime_src/core/tools/common/reports/ReportAiePartitions.cpp
index dacdc95c1..89cd88cc7 100644
--- a/src/runtime_src/core/tools/common/reports/ReportAiePartitions.cpp
+++ b/src/runtime_src/core/tools/common/reports/ReportAiePartitions.cpp
@@ -44,7 +44,7 @@ populate_aie_partition(const xrt_core::device* device)
     pt_entry.put("egops", qos.egops);
     pt_entry.put("fps", qos.fps);
     pt_entry.put("latency", qos.latency);
-    pt_entry.put("priority", qos.priority);
+    pt_entry.put("priority", xrt_core::query::aie_partition_info::parse_priority_status(qos.priority));
 
     partition.first->second.push_back(std::make_pair("", pt_entry));
   }
@@ -170,7 +170,7 @@ writeReport(const xrt_core::device* /*_pDevice*/,
         hw_context.get<std::string>("command_completions"),
         hw_context.get<std::string>("migrations"),
         std::to_string(hw_context.get<uint64_t>("errors")),
-        std::to_string(hw_context.get<uint64_t>("priority")),
+        hw_context.get<std::string>("priority"),
         std::to_string(hw_context.get<uint64_t>("gops")),
         std::to_string(hw_context.get<uint64_t>("egops")),
         std::to_string(hw_context.get<uint64_t>("fps")),
diff --git a/src/runtime_src/core/tools/xbutil2/OO_Reports.cpp b/src/runtime_src/core/tools/xbutil2/OO_Reports.cpp
index 56d1b2b4b..549eb5a1f 100644
--- a/src/runtime_src/core/tools/xbutil2/OO_Reports.cpp
+++ b/src/runtime_src/core/tools/xbutil2/OO_Reports.cpp
@@ -21,16 +21,16 @@ namespace {
 static void
 print_preemption_telemetry(const xrt_core::device* device)
 {
-  boost::property_tree::ptree telemetry_pt = xrt_core::telemetry::preemption_telemetry_info(device);
+  boost::property_tree::ptree empty_ptree;
+  std::stringstream ss;
+  boost::property_tree::ptree telemetry_pt = xrt_core::telemetry::preemption_telemetry_info(device).get_child("telemetry", empty_ptree);
+  ss << "Premption Telemetry Data\n";
   if (telemetry_pt.empty()) {
-    std::cout << "  No telemetry information available\n\n";
+    ss << " No hardware contexts running on device\n\n";
+    std::cout << ss.str();
     return;
   }
 
-  boost::property_tree::ptree empty_ptree;
-  std::stringstream ss;
-  boost::property_tree::ptree rtos_tasks = telemetry_pt.get_child("telemetry", empty_ptree);
-
   std::vector<Table2D::HeaderData> preempt_headers = {
     {"User Task", Table2D::Justification::left},
     {"Ctx ID", Table2D::Justification::left},
@@ -41,22 +41,18 @@ print_preemption_telemetry(const xrt_core::device* device)
   };
   Table2D preemption_table(preempt_headers);
 
-  int index = 0;
-  for (const auto& [name, rtos_task] : rtos_tasks) {
+  for (const auto& [name, rtos_task] : telemetry_pt) {
     const std::vector<std::string> rtos_data = {
-      std::to_string(index),
-      std::to_string(rtos_task.get<uint64_t>("slot_index")),
-      std::to_string(rtos_task.get<uint64_t>("preemption_flag_set")),
-      std::to_string(rtos_task.get<uint64_t>("preemption_flag_unset")),
-      std::to_string(rtos_task.get<uint64_t>("preemption_checkpoint_event")),
-      std::to_string(rtos_task.get<uint64_t>("preemption_frame_boundary_events")),
+      rtos_task.get<std::string>("user_task"),
+      rtos_task.get<std::string>("slot_index"),
+      rtos_task.get<std::string>("preemption_flag_set"),
+      rtos_task.get<std::string>("preemption_flag_unset"),
+      rtos_task.get<std::string>("preemption_checkpoint_event"),
+      rtos_task.get<std::string>("preemption_frame_boundary_events"),
     };
     preemption_table.addEntry(rtos_data);
-
-    index++;
   }
 
-  ss << "Premption Telemetry Data\n";
   ss << preemption_table.toString("  ") << "\n";
 
   std::cout << ss.str();
